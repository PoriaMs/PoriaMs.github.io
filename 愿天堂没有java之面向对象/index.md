# 愿天堂没有Java之面向对象


**JavaSE 笔记（一）**

<!--more-->

> Java 是一门非常严谨的语言

#### 面向对象概述

##### 认识一下嘛

- 面向对象编程就是就是拿或找东西过来编程

```java
public class Test {    
  public static void main(String[] args) {
    // 1、创建一个扫描器对象，用于接收用户输入的数据
    System.out.println("请您输入您的年龄：");
    int age = sc.nextInt();
    System.out.println(age);
    // 2、得到一个随机数对象，用于得到随机数       
    int data = r.nextInt(10) + 1 ; // 生成 1-10之间的随机数
    System.out.println(data);
  }
}
```

##### 定义类的注意事项

- 类名首字母大写，满足驼峰模式
- 一个 Java 文件可以定义多个类，但只有一个类可以被 public 修饰，且该类必须成为文件名称
- 一般建议一个 Java 文件只定义一个类

##### 类的成分

```java
public class Student{
  // 1、成员变量
  private String name;
  // 2、构造器
  public Student(){}
  // 3、方法
  public void run(){}
  // 4、代码块
  static{}
  // 5、内部类
  public class Heart{}
}
```

#### 构造器

##### 认识一下嘛

- 初始化类的对象并返回对象的地址

##### 格式

- 构造器格式

  ```java
  修饰符 类名（形参列表）{
  }
  ```

- 初始化对象格式

  ```java
  类名 对象变量 = new 构造器;
  ```

##### 分类和作用

```java
public class Student {
  // 成员变量
  private String name;
  private int age;
  // 1、无参数构造器
  public Student(){
  }
  // 2、有参数构造器
  public Student(String name, int age) {
    this.name = name;
    this.age = age;
  }
  // getter + setter方法
}
```

##### 注意事项

- 任何类定义出来，默认自带无参构造器，写不写都存在
- 一旦定义有参构造器，无参构造器就消失了，此时就需要自定义无参构造器

#### this 关键字

##### 认识一下嘛

- 作用：出现在成员方法中、构造器中，代表当前对象的地址，用于指定访问**当前对象**的成员变量、成员方法
- this 出现在构造器或者方法中，哪个对象调用它，this 就代表哪个对象

#### 面向对象三特征之一：封装

##### 认识一下嘛

- 基本思想：解决属性和方法属于哪个对象的问题
- 步骤：通常是将成员变量私有，然后提供方法去合理暴露
- 作用：提高业务功能设计的安全性，提高程序逻辑性和开发效率

##### 标准 JavaBean

- 可以理解为实体类，其对象可以用于封装数据，符合封装的思想
- 格式
  - 成员变量用 private 修饰
  - 提供每一个成员变量对应的 set 和 get 方法
  - 必须提供一个无参构造器

#### static 关键字

##### 认识一下嘛

- static 是静态的意思，可以修饰成员变量和成员方法
- static 修饰表示只在内存中**存储一份**，可以**被共享访问、修改**

##### 修饰成员变量

- 实例成员变量，无 static 修饰，属于对象，访问格式：

  ```java
  public class User {
    // 实例成员变量
    private int age;
  }
  对象.实例成员变量
  ```

- 静态成员变量，被 static 修饰，共享，访问格式（一般用第一种方式）：

  ```java
  public class User {
    // 静态成员变量
    public static String onlineNumber= 161;
  }
  类名.静态成员变量
  对象.静态成员变量
  ```

##### 修饰成员方法

- 实例成员方法，无 static 修饰，属于对象，只能用对象触发访问

  ```java
  public void run(){
    System.out.println(name + "poria");
  }
  对象.实例成员方法
  ```

- 静态成员方法，被 static 修饰，属于类，建议用类名访问，也可以用对象访问

  ```java
   public static int getMax(int a , int b){
     return a > b ? a : b;
   }
  类名.静态成员方法
  对象.静态成员方法
  ```

##### 注意事项

- 静态方法只能访问静态的成员，不可以直接访问实例成员
- 实例方法可以访问静态的成员，也可以访问实例成员
- 静态方法中不会出现 this 关键字

##### static 应用实例——工具类

- 工具类中定义的都是静态方法，调用方便，提高了代码复用（一次编写，处处可用）
- 注意事项：
  - 工具类的构造器一般都为私有，无需创建对象
  - 由于工具类中都是静态方法，直接用类名索引访问即可

##### static 应用知识——代码块

- 类的五大成分之一，定义在类中

- 分类

  - 静态代码块
    - 格式：`static{}`
    - 特点：需要通过 static 关键字修饰，随着类的加载而加载，并且**自动触发、只执行一次**

  - 构造代码块（很少用到）
    - 格式：`{}`
    - 特点：每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且**在构造器执行前执行**

##### static 应用知识——单例设计模式

- 单例模式：

  可以保证系统中，应用该模式的这个类永远只有一个实例，即**这个类永远只能创建一个对象**

  例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间

- 饿汉单例

  - 在用类获取对象的时候，对象已经提前创建好

    ```java
    /** 定义一个单例类 */
    public class SingleInstance {
      /** 定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */
      public static SingleInstance instance = new SingleInstance ();
      /** 单例必须私有构造器*/
      private SingleInstance (){
        System.out.println("创建了对象");
      }
    }
    ```

  - 设计步骤：

    - 定义一个类，把构造器私有
    - 定义一个静态变量储存一个对象

- 懒汉单例

  - 在真正需要对象的时候，才去创建一个对象（延迟加载）

    ```java
    /** 定义一个单例类 */
    class SingleInstance{
      /** 定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */
      public static SingleInstance instance ; // null
      /** 单例必须私有构造器*/
      private SingleInstance(){}
      /** 必须提供一个方法返回一个单例对象  */
      public static SingleInstance getInstance(){
        ...
        return ...;
      }
    }
    ```

  - 设计步骤

    - 定义一个类，把构造器私有
    - 定义一个静态变量存储一个对象
    - 提供一个返回单例对象的方法

#### 面向对象三特征之二：继承

##### 认识一下嘛

- Java中提供一个关键字extends，用这个关键字，可以让一个类和另一个类建立起父子关系

  ```java
  public class Student extends People {}
  ```

- Student 成为子类（派生类），People 称为父类（基类、超类）

- 提高了代码复用，减少代码冗余，增强类的功能拓展性

##### 设计规范

- 子类们的相同特征（共性属性、共性方法）放在父类中定义
- 子类独有的属性和行为应该定义在自己的类中

##### 特点

- 子类可以继承父类的属性（变量）和行为（方法），但是不能继承父类构造器
- Java 是单继承模式，一个类只能继承一个父类（不然就乱伦了
- Java 支持多层继承
- Java 中所有类都是 Object 的子类，Object 是祖宗类
- 子类是否可以继承父类的私有成员？
  - 我认为，可以继承，只是不能访问到
- 子类是否可以继承父类的静态成员和方法？
  - 我认为，不能继承，虽然子类可以使用父类的静态成员和方法，但是这是 static 的共享特性，共享并非是继承

##### 索引访问特点

- 在子类方法中访问成员和方法满足**就近原则**，子类中找不到找父类，父类中找不到就报错（可以类比于 JavaScript 中的原型链）

- 如果在子父类中出现了重名的成员或方法，而此时一定要在子类中调用父类的成员或方法时，需要用到 super 关键字，指定访问父类的成员或方法

  ```java
  super.父类成员变量
  super.父类成员方法  
  ```

##### 方法重写

- 子类写一个与父类一样的方法覆盖父类的方法
- `@Override`注解是放在重写后的方法上，作为重写是否正确的校验注解
- 注意事项和要求
  - 重写方法的名称、形参列表必须和被重写的方法一致（重写不是改写，戏说不是胡说）
  - 私有方法不能被重写，静态方法不能被重写
  - 子类重写父类方法时，访问权限必须大于或者等于父类

##### 子类构造器

- 子类中所有的构造器会默认先访问父类中无参构造器，然后再执行自己的
- 子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化
- 子类构造器的第一行语句默认都是：**super()，不写也存在**
- 如果父类中没有无参构造器，那么此时就会报错，子类就需要手动书写`super()`来调用父类的有参构造器

#### 包

##### 认识一下嘛

- 包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护

##### 建包

- 建包语句必须在第一行，包名建议全部英文小写

- 格式

  ```java
  package 公司域名倒写.技术名称
  
  package com.poria.tools
  ```

##### 导包

- 相同包下的类可以直接访问，不同包下的类必须导包,才可以使用

- 假如一个类中需要用到不同类，而这个两个类的名称是一样的，那么默认只能导入一个类，另一个类要带包名访问

- 格式

  ```java
  import 包名.类名
    
  import com.poria.tools.Test
  ```

#### 权限修饰符

##### 认识一下嘛

- 用来控制一个成员能够被访问的范围的
- 可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制

##### 分类及作用范围

| **修饰符** | **同一 个类中** | **同一个包中**  **其他类** | **不同包下的**  **子类** | **不同包下的**  **无关类** |
| ---------- | --------------- | -------------------------- | ------------------------ | -------------------------- |
| private    | √               |                            |                          |                            |
| 缺省       | √               | √                          |                          |                            |
| protected  | √               | √                          | √                        |                            |
| public     | √               | √                          | √                        | √                          |

#### 面向对象三特征之：多态

##### 认识一下嘛

- 同类型的对象，执行同一个行为，会表现出不同的行为特征

  ```java
  父类类型 对象名称 = new 子类构造器;
  接口 对象名称 = new 实现类构造器;
  ```

- 特点

  - 方法调用：编译看左边（父类），运行看右边（子类）
  - 变量调用：编译看左边，运行看左边（也就是说多态侧重行为多态）

##### 优势

- 在多态形式下，右边对象可以实现解耦合，便于维护和拓展

  ```java
  Animal a = new Tortoise();
  a.run(); // 后续业务行为随对象而变，后续代码无需修改
  
  Animal a = new Dog();
  a.run(); // 后续业务行为随对象而变，后续代码无需修改
  ```

- 同时也产生一个问题，就是多态下不可以使用子类独有功能

##### 多态下引用数据类型转换

- 自动类型转换：子类对象赋值给父类类型的变量指向

- 强制类型转换

  - 格式

    ```java
    子类 对象变量 = (子类)父类类型的变量
    ```

  - 可以解决多态产生的问题，可以实现子类调用自己独有的功能

    ```java
    Animal a = new Dog();
    Dog d = (Dog)a
    ```

  - Java 建议强类型转换前使用`instanceof`判断当前对象的真实类型

    ```java
    变量名 instanceof 真实类型
    ```


---

> 作者: [晨星_茯苓](/about/)  
> URL: https://poriams.github.io/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/  

